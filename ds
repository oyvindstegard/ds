#!/bin/sh
# -*- coding: utf-8 -*-
# ds
# Copyright (C) 2009-2015 Ã˜yvind Stegard <oyvind.stegard@ifi.uio.no>
###############################################################################
#                                LICENSE
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <http://www.gnu.org/licenses/>.
###############################################################################
#
# Script for simple synchronization of configured file sets between hosts.
#
# Requirements:
# - POSIX compliant (Bourne-compatible) shell (sh). GNU bash not required (code
#   should be free of "bashisms"). Developed and tested using the dash shell.
# - rsync for file/directory sync (tested with versions >=3.0.3)
# - ssh, preferably set up with public key authentication and ssh-agent to
#   remote hosts.
# - perl for the `stat' command
# - dconf and dbus-daemon for sync of dconf/gsettings trees (optional)
#
# Documentation: ds -H
#                ds conf example
#
# Bugs can be reported to author: Ã˜yvind Stegard <oyvind.stegard@ifi.uio.no>
#
# TODO better documentation
# TODO better logging of groups
# TODO clean up IFS-handling.
# TODO add "dist" command to push to multiple hosts in one go:
#      ds dist hostA [hostB ..] [items FOO BAR ..]
# TODO Use rsync '--ignore-missing-args' option, but only when local/remote
#      rsync version is >= 3.1.0.

# Global constants and default values.
readonly VERSION=1.3.1
readonly LOG_FILE=".ds.log"     # always relative to $HOME
readonly CONFIG_FILE=".ds.conf" # always relative to $HOME

# Console output functions:
# Terminal control; emit color escape sequence or reset if no args.
tty_color() {
    if [ "$GLOPT_COLORS" ] && [ -t 1 ]; then
        case "$1" in
            red)     echo -n '[0;31m'  ;;
            green)   echo -n '[0;32m'  ;;
            yellow)  echo -n '[0;33m'  ;;
            cyan)    echo -n '[01;36m' ;;
            magenta) echo -n '[01;35m' ;;
            reset)   echo -n '[0m'     ;;
        esac
    else
        return 1
    fi
}
print() {
    echo "$@"
}
print_verbose() {
    [ "$GLOPT_VERB" ] && print "$@"
}
print_red() {
    tty_color red; print "$@"; tty_color reset
}
print_green() {
    tty_color green; print "$@"; tty_color reset
}
print_yellow() {
    tty_color yellow; print "$@"; tty_color reset
}
print_cyan() {
    tty_color cyan; print "$@"; tty_color reset
}
print_magenta() {
    tty_color magenta; print "$@"; tty_color reset
}
print_err() {
    print_red -n "E: "
    print "$@"
}
print_warn() {
    print_yellow -n "W: "
    print "$@"
}
debug() {
    [ "$DS_DEBUG" ] || return 1
    print_cyan -n "D: "
    print "$@"
}
# Escape special chars in paths
path_escape_compatible() {
    echo "$1"|sed -e 's/\([ 	()"$#&]\)/\\\1/g' -e 's/\[/\\[/g' -e 's/\]/\\]/g'
}

################################################################################
# Ask Yes/No/Quit interactively. Default answer is yes, and
# yes will be auto-answered if global GLOPT_YES-variable is set.
# If QUIT is answered, then this function will exit.
################################################################################
ask_ynq() {
    if [ "$GLOPT_YES" ]; then
        print "$* [Y/n/q] y"
        return 0
    fi

    local answer
    read -p "$* [Y/n/q] " answer
    case $answer in
        y*|Y*|"")    return 0 ;;
        q*|Q*)       print "Quit."; exit 2 ;;
        *)           return 1 ;;
    esac
}
ask_abort() {
    ask_ynq "$*, abort ?" && print_red "Aborted." && exit 255
}


################################################################################
# Attempt to find max mtime recursively for a list of paths.
#
# First arg must be either 'remote' or 'local', while the rest of the args are
# paths. Echoes timestamp as seconds since epoch, a tab character, then the
# corresponding path. This function requires perl.
################################################################################
max_mtime() {
    type perl 1>/dev/null 2>&1 || {
        print_err "Missing required dependency for stat command: perl"
        print_err "It has to be available somewhere in your PATH both locally and on remote host(s)."
        return 255
    }

    local path paths= remote=
    [ "$1" = remote ] && remote=1; shift
    while [ "$1" ]; do
        if [ "$remote" ]; then
            path=`path_escape_compatible "$1"`
        else
            path="$1"
        fi
        list_append paths "$path"
        shift
    done
    
    # Use perl for a portable way to iterate paths recursively and determine
    # the most recently modified file or directory.
    local progtmp
    progtmp=`mktemp -t ds_max_mtime.pl.XXXXX`
    cat > $progtmp <<"EOP"
#!/usr/bin/env perl
use strict;
my $mtime_newest = 0;
my $path_newest = "";
sub traverse {
    my $path = $_[0];
    my @stats = stat($path);
    if (@stats) {
        my $mtime = $stats[9];
        if ($mtime > $mtime_newest) {
            $mtime_newest = $mtime;
            $path_newest = $path;
        }
    }
    if (-d "$path" && !(-l "$path")) {
        my $DH;
        opendir($DH, $path) or return;
        while (defined (my $entry = readdir($DH))) {
            next if ($entry eq "." || $entry eq "..");
            &traverse($path . "/" . $entry);
        }
        closedir($DH);
    }
}
foreach my $path (@ARGV) {
    &traverse($path);
}
if ($mtime_newest) {
    print "$mtime_newest\t$path_newest\n";
} else {
    exit 1;
}
EOP
    local IFS exitcode
    newline_IFS
    if [ "$remote" ]; then
        ssh $SSH_OPTS $HOST perl - $paths < $progtmp
        exitcode=$?
    else
        perl $progtmp $paths
        exitcode=$?
    fi
    reset_IFS
    rm -f $progtmp
    return $exitcode
}

################################################################################
# Handler for files and directories
#
# If OP is 'stat', then the following applies:
#   - Variable MAX_MTIME_REMOTE will be set to higest
#     modification timestamp found amongst remote files/dirs.
#   - Variable MAX_MTIME_REMOTE_PATH will be set to the remote
#     path with highest mtime.
#   - Variable MAX_MTIME_LOCAL will be set to highest
#     modification timestamp found amongst local files/dirs.
#   - Variable MAX_MTIME_LOCAL_PATH will be set to the local
#     path with highest mtime.
#   - Variable CHANGES_PUSH contains changes to existing files
#     that would be pushed.
#   - Variable CHANGES_FETCH contains changes to existing files
#     that would be fetched.
#
# If OP is 'push' or 'fetch', then variable ERRORS will contain
# any error messages for failed rsync invocations.
#
# Retcode 10 if anything fails.
# Retcode 100 for invalid OP.
# Retcode 255 for pre-requisite or fatal errors
################################################################################
handler_file() {
    type rsync 1>/dev/null 2>&1 || {
        print_err "Missing required dependency: rsync"
        print_err "It has to be available somewhere in your PATH."
        return 255
    }
    reset_IFS
    local retval oldpwd
    oldpwd=`pwd`
    cd "$HOME"                # Jump to home-directory as default base-path
    if [ $? -ne 0 ]; then
        print_err "Could not chdir to home directory $HOME"
        return 255
    fi
    handler_file_internal "$@"
    retval=$?
    cd "$oldpwd"              # Jump back
    return $retval
}
handler_file_internal() {
    local extraopts
    extraopts=$RSYNC_EXTRA_OPTS
    unset ERRORS

    # RSync command line opts is newline-separated. We bend over backwards to
    # properly support file names with spaces in them, while also batching
    # together multiple paths into the same rsync invocations to make things the
    # most efficient.

    [ "$extraopts" ] && [ "$OP" != stat ] && print "Extra rsync options:" $extraopts

    [ "$GLOPT_DRYRUN" ] && list_append extraopts -n
    [ "$GLOPT_VERB" ] && list_append extraopts -v
    [ "$GLOPT_COMP" ] && list_append extraopts -z
    [ "$TARGET_DELETES" ] && list_append extraopts --delete
    [ "$FORCE_UPDATE" ] || list_append extraopts --update

    # Standard for all rsync invocations is to send full paths to/from remote
    # part and sync to either / or $HOME, depending on if the path is absolute
    # or relative in config.
    local stdopts=
    list_append stdopts --archive
    list_append stdopts --relative
    list_append stdopts --no-implied-dirs
    list_append stdopts --protect-args

    # Setup RSYNC_RSH
    export RSYNC_RSH="ssh `echo $SSH_OPTS`"
    
    local relative_paths= relative_paths_host= absolute_paths= absolute_paths_host=
    while [ "$1" ]; do
        if [ "${1#/}" = "$1" ]; then
            list_append relative_paths "$1"
            list_append relative_paths_host "$HOST:$1"
        else
            list_append absolute_paths "$1"
            list_append absolute_paths_host "$HOST:$1"
        fi
        shift
    done
    
    local IFS
    newline_IFS
    case $OP in
        stat)
            local output retcode
            unset CHANGES_FETCH CHANGES_PUSH
            unset MAX_MTIME_LOCAL MAX_MTIME_LOCAL_PATH
            unset MAX_MTIME_REMOTE MAX_MTIME_REMOTE_PATH

            # Find max mtime for local and remote
            local paths=
            [ "$relative_paths" ] && list_append paths "$relative_paths"
            [ "$absolute_paths" ] && list_append paths "$absolute_paths"

            # Run max_mtime function in background on the local side, so it can run it parallel with
            # remote check.
            local local_mtime_pid local_mtime_outputfile
            local_mtime_outputfile=`mktemp`
            max_mtime local $paths </dev/null 1>"$local_mtime_outputfile" 2>&1 & local_mtime_pid=$!
            
            output=`max_mtime remote $paths`
            retcode=$?
            if [ $retcode -ne 0 ] || [ -z "$output" ]; then
                print_err "handler_file: failed to determine max remote mtime for paths: $paths"
                return 10
            else
                MAX_MTIME_REMOTE=`echo "$output"|cut -f1`
                MAX_MTIME_REMOTE_PATH=`echo "$output"|cut -f2-`
            fi

            # Wait for local max_mtime process to end
            wait $local_mtime_pid
            retcode=$?
            if [ $retcode -ne 0 ] && [ $retcode -ne 127 ]; then
                print_err "handler_file: failed to determine max local mtime for paths: $paths"
                rm -f "$local_mtime_outputfile"
                return 10
            else
                MAX_MTIME_LOCAL=`cut -f1 "$local_mtime_outputfile"`
                MAX_MTIME_LOCAL_PATH=`cut -f2- "$local_mtime_outputfile"`
                rm -f "$local_mtime_outputfile"
            fi
            
            # Check for file modifications with rsync for push
            if [ "$relative_paths" ]; then
                output=`rsync -uO --existing -in $stdopts $relative_paths $HOST:`
                if [ $? -ne 0 ]; then
                    print_err "rsync failed for paths: " $relative_paths
                    return 10
                fi
                [ "$output" ] && list_append CHANGES_PUSH "$output"
            fi
            if [ "$absolute_paths" ]; then
                output=`rsync -uO --existing -in $stdopts $absolute_paths $HOST:/`
                if [ $? -ne 0 ]; then
                    print_err "rsync failed for paths:" $absolute_paths
                    return 10
                fi
                [ "$output" ] && list_append CHANGES_PUSH "$output"
            fi
            # Check for file modifications with rsync for fetch
            if [ "$relative_paths_host" ]; then
                output=`rsync -uO --existing -in $stdopts $relative_paths_host .`
                if [ $? -ne 0 ]; then
                    print_err "rsync failed for paths:" $relative_paths
                    return 10
                fi
                [ "$output" ] && list_append CHANGES_FETCH "$output"
            fi
            if [ "$absolute_paths_host" ]; then
                output=`rsync -uO --existing -in $stdopts $absolute_paths_host /`
                if [ $? -ne 0 ]; then
                    print_err "rsync failed for paths:" $absolute_paths
                    return 10
                fi
                [ "$output" ] && list_append CHANGES_FETCH "$output"
            fi
            return 0
            ;;

        push)
            local retcode
            if [ "$relative_paths" ]; then
                print "Pushing to remote host $HOST:" $relative_paths
                rsync $stdopts $extraopts $relative_paths "$HOST:"
                retcode=$?
                if [ $retcode -ne 0 ]; then
                    print_err "handler_file: rsync failed with error $retcode (path list:" $relative_paths ")"
                    ERRORS="${ERRORS:+$ERRORS, }rsync failed with error $retcode (path list: `echo $relative_paths`)"
                fi
            fi
            if [ "$absolute_paths" ]; then
                print "Pushing to remote host $HOST:" $absolute_paths
                rsync $stdopts $extraopts $absolute_paths "$HOST:/"
                retcode=$?
                if [ $retcode -ne 0 ]; then
                    print_err "handler_file: rsync failed with error $retcode (paths: " $absolute_paths ")"
                    ERRORS="${ERRORS:+$ERRORS, }rsync failed with error $retcode (paths: `echo $absolute_paths`)"
                fi
            fi
            ;;

        fetch)
            local retcode
            if [ "$relative_paths_host" ] && [ "$relative_paths" ]; then
                print "Fetching from remote host $HOST:" $relative_paths
                rsync $stdopts $extraopts $relative_paths_host .
                retcode=$?
                if [ $retcode -ne 0 ]; then
                    print_err "handler_file: rsync failed with error $retcode (path list: " $relative_paths ")"
                    ERRORS="${ERRORS:+$ERRORS, }rsync failed with error $retcode (path list: `echo $relative_paths`)"
                fi
            fi
            if [ "$absolute_paths_host" ] && [ "$absolute_paths" ]; then
                print "Fetching from remote host $HOST:" $absolute_paths
                rsync $stdopts $extraopts $absolute_paths_host /
                retcode=$?
                if [ $retcode -ne 0 ]; then
                    print_err "handler_file: rsync failed with error $retcode (paths:" $absolute_paths ")"
                    ERRORS="${ERRORS:+$ERRORS, }rsync failed with error $retcode (paths: `echo $absolute_paths`)"
                fi
            fi
            ;;
        
        *)
            return 100
            ;;
    esac
    [ "$ERRORS" ] && return 10 || return 0
}

################################################################################
# SSH control master setup and teardown
################################################################################
SSH_CTL_SOCKET="/tmp/ds-$$-%r@%h:%p.sock"   # Per [USER@]HOST master control socket
SSH_OPTS="-x
-e
none"                                       # Newline-separated list of ssh options
SSH_SETUP_HOSTS=                            # List of all hosts with ssh setup

# Expects <[USER@]HOST> as first argument
ssh_setup() {
    type ssh 1>/dev/null 2>&1 || {
        print_err "Missing required dependency: ssh"
        print_err "It has to be available somewhere in your PATH."
        return 255
    }
    [ "$1" ] || return 1
    local host="$1"
    SSH_OPTS="-x
-e
none" # pure newline IFS compatible

    # Try to set up ssh master connection
    if ! ssh -o ControlPath=$SSH_CTL_SOCKET -O check $host 1>/dev/null 2>&1; then
        ssh -xNf -e none -o ControlMaster=yes -o ControlPath=$SSH_CTL_SOCKET $host
        if [ $? -eq 0 ]; then
            SSH_OPTS="$SSH_OPTS
-o
ControlPath=$SSH_CTL_SOCKET" # pure newline IFS compatible
            SSH_SETUP_HOSTS="$SSH_SETUP_HOSTS $host"
        fi
    fi
}
ssh_cleanup() {
    local host
    for host in $SSH_SETUP_HOSTS; do
        ssh -o ControlPath=$SSH_CTL_SOCKET -O exit $host 1>/dev/null 2>&1
    done
}
trap ssh_cleanup EXIT INT TERM

################################################################################
# Utility functions for working with local and remote DBUS sessions (required
# for dconf)
################################################################################
DBUS_REMOTE_SESSION_PID=
DBUS_REMOTE_SESSION_ADDRESS=
dbus_open_remote_session() {
    local tmpfile addr pid
    if [ "$DBUS_REMOTE_SESSION_ADDRESS" ]; then
        return 0 # a remote dbus session already available
    fi
    
    tmpfile=`mktemp`
    # Try to obtain address of any running dbus instance on remote host first
    ssh $SSH_OPTS $HOST 'set -e;U=`id -nu`;DCPID=`pgrep -o -u $U dconf-service`;test "$DCPID" -a -f /proc/$DCPID/environ;xargs -0 -n1 -a /proc/$DCPID/environ|grep DBUS_SESSION_BUS_ADDRESS|cut -d= -f2-' > $tmpfile
    addr=`cat $tmpfile`
    if [ "$addr" ]; then
        # found already running remote session bus, use that
        DBUS_REMOTE_SESSION_ADDRESS=$addr
        DBUS_REMOTE_SESSION_PID=
        rm -f $tmpfile
        return 0
    fi

    # No running dbus session found on remote host, set up our own
    ssh $SSH_OPTS $HOST 'dbus-daemon --session --fork --print-pid --print-address' > $tmpfile
    addr=`head -n1 $tmpfile`
    pid=`tail -n1 $tmpfile`
    if [ -z "$addr" ] || [ -z "$pid" ]; then
        print_err "dbus_open_remote_session: failed to start dbus-daemon on remote host"
        rm -f $tmpfile
        return 2
    fi
    rm -f $tmpfile

    DBUS_REMOTE_SESSION_PID=$pid
    DBUS_REMOTE_SESSION_ADDRESS=$addr
    return 0
}

dbus_close_remote_session() {
    if [ "$DBUS_REMOTE_SESSION_PID" ]; then
        # We have started a remote dbus session ourselves, kill it
        ssh $SSH_OPTS $HOST "kill $DBUS_REMOTE_SESSION_PID 2>/dev/null" || print_warn "dbus_close_remote_session: failed to kill remotely started dbus-daemon with pid $DBUS_REMOTE_SESSION_PID"
        DBUS_REMOTE_SESSION_PID=
    fi
    DBUS_REMOTE_SESSION_ADDRESS=
}

DBUS_LOCAL_SESSION_ADDRESS=
DBUS_LOCAL_SESSION_PID=
dbus_open_local_session() {
    if [ "$DBUS_LOCAL_SESSION_ADDRESS" ]; then
        # local session already available
        return 0
    fi

    local tmpfile addr pid
    if [ -z "$DBUS_SESSION_BUS_ADDRESS" ]; then
        # no local dbus-daemon available, start one up
        tmpfile=`mktemp`
        dbus-daemon --session --fork --print-pid --print-address > $tmpfile
        if [ $? -ne 0 ]; then
            print_err "dbus_open_local_session: failed to start dbus-daemon on local host"
            rm -f $tmpfile
            return 1
        fi
        addr=`head -n1 $tmpfile`
        pid=`tail -n1 $tmpfile`
        if [ -z "$addr" ] || [ -z "$pid" ]; then
            print_err "dbus_open_local_session: failed to start dbus-daemon on local host"
            rm -f $tmpfile
            return 2
        fi
        rm -f $tmpfile
        DBUS_LOCAL_SESSION_PID=$pid
        DBUS_LOCAL_SESSION_ADDRESS=$addr
    else
        # local session already available
        DBUS_LOCAL_SESSION_ADDRESS=$DBUS_SESSION_BUS_ADDRESS
        DBUS_LOCAL_SESSION_PID=
    fi
    return 0
}

dbus_close_local_session() {
    if [ "$DBUS_LOCAL_SESSION_PID" ]; then
        kill $DBUS_LOCAL_SESSION_PID || print_warn "dbus_close_local_session: failed to kill locally started dbus-daemon"
        DBUS_LOCAL_SESSION_PID=
    fi
    DBUS_LOCAL_SESSION_ADDRESS=
}

################################################################################
# Handler for dconf trees
################################################################################
handler_dconf() {
    reset_IFS

    type dconf 1>/dev/null 2>&1 || {
        print_err "Missing required dependency for dconf sync: dconf"
        print_err "It has to be available somewhere in your PATH."
        return 255
    }

    local tree="$1"
    unset ERRORS

    if [ -z "$tree" ] || [ / = "$tree" ]; then
        print_err "handler_dconf: database root '$tree' not allowed"
        ERRORS="dconf tree $tree: database root not allowed"
        return 1
    fi

    if [ "${tree%/}" = "$tree" ]; then
        # we only support trees, so add the last slash:
        tree="$tree/"
    fi

    case $OP in
        push)
            # Transfer dconf tree to remote host
            print "Transferring dconf tree $tree to remote host $HOST"

            dbus_open_remote_session
            if [ $? -ne 0 ]; then
                print_err "handler_dconf: unable to acquire remote dbus session"
                return 1
            fi
            
            if [ "$GLOPT_DRYRUN" ]; then
                print "handler_dconf: dry run commands:"
                print "handler_dconf:" "dconf dump $tree | ssh `echo $SSH_OPTS` $HOST 'DBUS_SESSION_BUS_ADDRESS=$DBUS_REMOTE_SESSION_ADDRESS dconf load $tree'"
            else
                dconf dump "$tree" | ssh $SSH_OPTS $HOST "DBUS_SESSION_BUS_ADDRESS=$DBUS_REMOTE_SESSION_ADDRESS dconf load $tree"
                if [ $? -ne 0 ]; then
                    print_err "handler_dconf: failed to send data to host $HOST"
                    ERRORS="dconf tree $tree: failed to send data to host $HOST"
                    dbus_close_remote_session
                    return 1
                fi
            fi

            dbus_close_remote_session
            return 0
            ;;

        fetch)
            # Retrieve dconf tree from remote host
            print "Retrieving dconf tree $tree from remote host $HOST"

            dbus_open_local_session
            if [ $? -ne 0 ]; then
                print_err "handler_dconf: unable to acquire local dbus session"
                return 1
            fi
            
            if [ "$GLOPT_DRYRUN" ]; then
                print "handler_dconf: dry run commands:"
                print "handler_dconf:" "ssh `echo $SSH_OPTS` $HOST 'dconf dump $tree'|DBUS_SESSION_BUS_ADDRESS=$DBUS_LOCAL_SESSION_ADDRESS dconf load $tree"
            else
                ssh $SSH_OPTS $HOST "dconf dump $tree" |DBUS_SESSION_BUS_ADDRESS=$DBUS_LOCAL_SESSION_ADDRESS dconf load "$tree"
                if [ $? -ne 0 ]; then
                    print_err "handler_dconf: failed to retrieve dconf data from host $HOST"
                    ERRORS="dconf tree $tree: failed to retrieve dconf data from host $HOST"
                    dbus_close_local_session
                    return 1
                fi
            fi

            dbus_close_local_session
            return 0
            ;;
        
        *)
            return 2
            ;;
    esac
}

################################################################################
# Execute stat command
################################################################################
do_command_stat() {
    [ -z "$CURRENT_ITEM" ] && return 1

    # Setup SSH, possibly creating a master connection
    ssh_setup "$HOST"
        
    # Do sync status for files/dirs
    if property_values_exist ITEM $CURRENT_ITEM FILES; then
        local IFS
        newline_IFS
        handler_file `list_property_values ITEM $CURRENT_ITEM FILES`
        local retcode=$?
        if [ $retcode -ne 0 ]; then
            print_red -n "X  ";print "Unable to determine status due to error."
            return 1
        fi
        newline_IFS
        if [ -z "$MAX_MTIME_LOCAL" ] || [ -z "$MAX_MTIME_REMOTE" ]; then
            print "?  Unable to determine most recent modification time."
        elif [ $MAX_MTIME_LOCAL -gt $MAX_MTIME_REMOTE ]; then
            print -n "<  Most recent modification time found locally: "
            LC_TIME=C date -d @$MAX_MTIME_LOCAL
        elif [ $MAX_MTIME_LOCAL -eq $MAX_MTIME_REMOTE ]; then
            print_green -n "== ";print "Equal most recent modification time on both sides."
        else
            print_yellow -n " > ";print -n "Most recent modification time found remotely: "
            LC_TIME=C date -d @$MAX_MTIME_REMOTE
        fi

        if [ "$CHANGES_PUSH" ] && [ -z "$CHANGES_FETCH" ]; then
            print -n "<  "; print "Local file changes."
            local change
            for change in $CHANGES_PUSH; do
                print_verbose "$change"
            done
        elif [ -z "$CHANGES_PUSH" ] && [ "$CHANGES_FETCH" ]; then
            print_yellow -n " > "; print "Remote file changes."
            local change
            for change in $CHANGES_FETCH; do
                print_verbose "$change"
            done
        elif [ "$CHANGES_PUSH" ] && [ "$CHANGES_FETCH" ]; then
            print_red -n "<> "; print "Both local and remote file changes."
            local change
            for change in $CHANGES_PUSH; do
                print_verbose "   $change"
            done
            print_verbose
            for change in $CHANGES_FETCH; do
                print_verbose "   $change"
            done
        fi
    fi
}

# Execute sync
# Variable CURRENT_ITEM should hold the name of item to sync
do_command_sync() {
    local item
    item="$CURRENT_ITEM"
    [ -z "$item" ] && return 1

    # Setup SSH, possibly creating control master connection
    ssh_setup "$HOST"
        
    print
    if item_flag_effective_value $item always_ask || [ "$GLOPT_INT" ]; then
        if [ $OP = push ] && ! ask_ynq "Push item $item to host $HOST ?"; then
            return 0
        fi
        if [ $OP = fetch ] && ! ask_ynq "Fetch item $item from host $HOST ?"; then
            return 0
        fi
    fi

    # Do preconditions first
    if property_values_exist ITEM $item CONDS; then
        local cond
        local IFS
        newline_IFS
        for cond in `list_property_values ITEM $item CONDS`; do
            reset_IFS
            local retval
            eval "$cond" # run cond
            retval=$?
            if [ $retval -ne 0 ]; then
                print_warn "Item pre-condition failed with exit code $retval:"; print "   $cond"; print
                ask_ynq "Do you wish to skip this item ?"
                if [ $? -eq 0 ]; then
                    continue 2
                fi
                # Continue evaluating the rest of the pre-conditions, anyway ..
            fi
        done
    fi

    # Do any kills
    unset NO_KILL_CONFIRMATION
    if property_values_exist ITEM $item KILLS; then
        if ! item_flag_effective_value $item ask_before_kill; then
            NO_KILL_CONFIRMATION=1
        fi
        newline_IFS
        ask_kill_local_remote `list_property_values ITEM $item KILLS`
        reset_IFS
    fi

    # Set any special rsync options for the item
    unset RSYNC_EXTRA_OPTS
    if property_values_exist ITEM $item RSYNC_OPTS; then
        RSYNC_EXTRA_OPTS=`list_property_values ITEM $item RSYNC_OPTS`
    fi

    # Set up any flags
    unset TARGET_DELETES
    if item_flag_effective_value $item target_deletes && [ -z "$GLOPT_ONLY_UPDATE" ]; then
        TARGET_DELETES=1
    fi

    unset FORCE_UPDATE
    if item_flag_effective_value $item force_update && [ -z "$GLOPT_ONLY_UPDATE" ]; then
        FORCE_UPDATE=1
    fi
    
    local logmsg=
    unset ERRORS # handlers populate this variable with any error messages

    # Max mtime check
    if item_flag_effective_value $item max_mtime_check; then
        local oldOP=$OP
        # Temporarily set OP to 'stat' before invoking handler_file
        OP=stat
        newline_IFS
        handler_file `list_property_values ITEM $CURRENT_ITEM FILES`
        local retcode=$?
        if [ $retcode -ne 0 ]; then
            print_warn "Unable to determine max mtime status due to error."
            ask_ynq "Skip item ?" && return 0
        fi
        reset_IFS
        OP=$oldOP

        if [ $MAX_MTIME_LOCAL -gt $MAX_MTIME_REMOTE ] && [ $OP = fetch ]; then
            print_warn "Most recently modified path found locally: $MAX_MTIME_LOCAL_PATH, modified `LC_TIME=C date -d @$MAX_MTIME_LOCAL`"
            ask_ynq "Do you want to skip fetching from remote ?" && return 0
        elif [ $MAX_MTIME_REMOTE -gt $MAX_MTIME_LOCAL ] && [ $OP = push ]; then
            print_warn "Most recently modified path found remotely: $HOST:$MAX_MTIME_REMOTE_PATH, modified `LC_TIME=C date -d @$MAX_MTIME_REMOTE`"
            ask_ynq "Do you want to skip pushing to remote ?" && return 0
        fi
    fi
    
    # Do files/dirs
    if property_values_exist ITEM $item FILES; then
        newline_IFS
        handler_file `list_property_values ITEM $item FILES`
        if [ $? -ne 0 ]; then
            print_warn "File handler reported errors while syncing item files"
            logmsg="$ERRORS"
        else
            print_green OK
        fi
        reset_IFS
    fi
    # Do dconf trees
    if property_values_exist ITEM $item DCONF_TREES; then
        local tree
        newline_IFS
        for tree in `list_property_values ITEM $item DCONF_TREES`; do
            reset_IFS
            handler_dconf "$tree"
            if [ $? -ne 0 ]; then
                print_warn "Sync of dconf tree $tree failed"
                logmsg="${logmsg:+$logmsg, }$ERRORS"
            else
                print_green OK
            fi
        done
    fi

    if [ -z "$logmsg" ]; then
        log_hook OK
    else
        log_hook "$logmsg"
    fi
}

ask_kill_local_remote() {
    reset_IFS
    local local_pids=
    local remote_pids=
    local username=$USER
    if [ "${HOST#*@*}" != "$HOST" ]; then
        username="`echo $HOST|cut -d@ -f1`"
    fi

    local pids= pid
    while [ "$1" ]; do
        pids=`pgrep -f -U $USER "$1"` && { for pid in $pids; do [ $pid -ne $$ ] && local_pids="$local_pids $pid"; done; }
        pids=`ssh $SSH_OPTS $HOST "pgrep -f -U $username '$1'"` && { for pid in $pids; do remote_pids="$remote_pids $pid"; done; }
        shift
    done

    local_pids="${local_pids## }"
    remote_pids="${remote_pids## }"

    if [ "$local_pids" ]; then
        print_warn "Processes associated with item $CURRENT_ITEM found running locally:"
        ps -p "$local_pids" -o pid,cmd
        print
        if [ "$NO_KILL_CONFIRMATION" ]; then
            print "Killing now"
            kill $local_pids && sleep 3 || ask_abort "Failed to kill local processes associated with item $CURRENT_ITEM"
        else
            if ask_ynq "Kill them before sync ?"; then
                print "Killing now"
                kill $local_pids && sleep 3 || ask_abort "Failed to kill local processes associated with item $CURRENT_ITEM"
            fi
        fi
    fi

    if [ "$remote_pids" ]; then
        print_warn "Processes associated with item $CURRENT_ITEM found running remotely:"
        ssh $SSH_OPTS $HOST "ps -p '$remote_pids' -o pid,cmd"
        print
        if [ "$NO_KILL_CONFIRMATION" ]; then
            print "Killing now"
            ssh $SSH_OPTS $HOST kill $remote_pids && sleep 3 || ask_abort "Failed to kill remote processes associated with item $CURRENT_ITEM"
        else
            if ask_ynq "Kill them before sync ?"; then
                print "Killing now"
                ssh $SSH_OPTS $HOST kill $remote_pids && sleep 3 || ask_abort "Failed to kill remote processes associated with item $CURRENT_ITEM"
            fi
        fi
    fi
}

log_hook() {
    { [ "$GLOPT_DRYRUN" ] || [ "$GLOPT_NOLOG" ]; } && return 0 # Log nothing if dry run or --nolog option.
    local message datestamp
    message=$1
    datestamp=`date +'%Y-%m-%d %H:%M'`

    [ "$message" ] && message=", $message"
    case $OP in
        push)
            echo "$datestamp <  PUSH ${CURRENT_GROUP:+group $CURRENT_GROUP }item $CURRENT_ITEM to host $HOST$message" >> "$HOME/$LOG_FILE"

            # Update remote log file
            echo "$datestamp  > REMOTE_PUSH ${CURRENT_GROUP:+group $CURRENT_GROUP }item $CURRENT_ITEM from host `hostname`$message" |\
                 ssh $SSH_OPTS $HOST "cat - >> $LOG_FILE"
            if [ $? -ne 0 ]; then
                print_warn "Failed to update remote log file"
            fi
            ;;

        fetch)
            echo "$datestamp  > FETCH ${CURRENT_GROUP:+group $CURRENT_GROUP }item $CURRENT_ITEM from host $HOST$message" >> "$HOME/$LOG_FILE"

            # Update remote log file
            echo "$datestamp <  REMOTE_FETCH ${CURRENT_GROUP:+group $CURRENT_GROUP }item $CURRENT_ITEM from host `hostname`$message" |\
                 ssh $SSH_OPTS $HOST "cat - >> $LOG_FILE"
            if [ $? -ne 0 ]; then
                print_warn "Failed to update remote log file"
            fi
            ;;
    esac
}

log_color_filter() {
    if [ -z "$GLOPT_COLORS" ] || ! [ -t 1 ]; then
        while read line; do echo "$line"; done
    else
        while read date time direction op a b c d e f g h; do
            echo -n "$date $time $direction $op "
            if [ "$a" = group ]; then
                echo -n "group "
                tty_color magenta
                echo -n "$b "
                tty_color reset
                echo -n "item "
                tty_color cyan
                echo -n "$d "
                tty_color reset
                if [ "${h%OK}" != "$h" ]; then
                    echo -n "$e $f $g ${h%OK}"
                    tty_color green
                    echo OK
                    tty_color reset
                else
                    echo -n "$e $f $g "
                    tty_color red
                    echo "$h"
                    tty_color reset
                fi
            else
                echo -n "item "
                tty_color cyan
                echo -n "$b "
                tty_color reset
                rest="$f${g:+ $g}${h:+ $h}"
                if [ "${rest%OK}" != "$rest" ]; then
                    echo -n "$c $d $e ${rest%OK}"
                    tty_color green
                    echo OK
                    tty_color reset
                else
                    echo -n "$c $d $e "
                    tty_color red
                    echo "$rest"
                    tty_color reset
                fi
            fi
        done
    fi
}

do_command_log() {
    if [ -z "$HOST" ] && [ ! -f "$HOME/$LOG_FILE" ]; then
        print_warn "Log file ~/$LOG_FILE not found."
        return 1
    fi

    if [ "$LOG_LASTOP" ]; then
        local lastops_tmpfile
        lastops_tmpfile=`mktemp`
        if [ "$HOST" ]; then
            # Setup SSH, possibly creating control master connection
            ssh_setup "$HOST"

            print "Last operation per configured item or group in log on remote host: $HOST"
            print
            local tmpfile
            tmpfile=`mktemp`
            ssh $SSH_OPTS $HOST "cat $LOG_FILE" > $tmpfile
            case $? in # FIXME: duplicated error handling code (look further down).
                0|1) : ;; # OK
                2)
                    print_warn "Log file ~/$LOG_FILE not found on remote host $HOST."
                    rm -f $tmpfile
                    return 1
                    ;;
                255)
                    print_err "Could not connect to host $HOST"
                    rm -f $tmpfile
                    return 1
                    ;;
                *)
                    print_err "Unknown error while getting log file on remote host $HOST"
                    rm -f $tmpfile
                    return 1
                    ;;
            esac
            for item in `list_items`; do
                fgrep " item $item" "$tmpfile"|tail -n1 >> "$lastops_tmpfile"
            done
            
            rm -f $tmpfile
        else
            print "Last operation per configured item or group in local log"
            print
            for item in `list_items`; do
                fgrep " item $item" "$HOME/$LOG_FILE"|tail -n1 >> "$lastops_tmpfile"
            done
        fi
        sort -k1,2 "$lastops_tmpfile" | log_color_filter
        rm -f "$lastops_tmpfile"

        return 0
    fi

    if [ "$LOG_CLEAR" ]; then
        # Clear logfile requested
        if [ "$HOST" ]; then
            # Setup SSH, possibly creating control master connection
            ssh_setup "$HOST"

            print "Clearing log file ~/$LOG_FILE on remote host $HOST .."
            ssh $SSH_OPTS $HOST 'test -f $LOG_FILE'
            if [ $? -ne 0 ]; then
                print_err "Log file not found on remote host $HOST."
                return 1
            else
                ssh $SSH_OPTS $HOST "echo -n > $LOG_FILE"
                [ $? -ne 0 ] && print_err "Failed to clear log file on remote host $HOST" && return 1
                return 0
            fi
        else
            print "Clearing log file ~/$LOG_FILE .."
            echo -n > "$HOME/$LOG_FILE"
            [ $? -ne 0 ] && print_err "Failed to clearn log file." && return 1
            return 0
        fi
    fi
    
    local regexp=
    [ "$LOG_REGEXP" ] && regexp="$LOG_REGEXP"
    [ "$LOG_ALL" ] && regexp='.'

    local tmpfile=
    local logfile="$HOME/$LOG_FILE"
    if [ "$HOST" ]; then
        # Setup SSH, possibly creating control master connection
        ssh_setup "$HOST"

        tmpfile=`mktemp`
        ssh $SSH_OPTS $HOST cat $LOG_FILE > $tmpfile
        case $? in
            0|1) : ;; # OK
            2)
                print_warn "Log file ~/$LOG_FILE not found on remote host $HOST."
                rm -f $tmpfile
                return 1
                ;;
            255)
                print_err "Could not connect to host $HOST"
                rm -f $tmpfile
                return 1
                ;;
            *)
                print_err "Unknown error while getting log file on remote host $HOST"
                rm -f $tmpfile
                return 1
                ;;
        esac
        logfile="$tmpfile"
    fi
        
    if [ -z "$regexp" ]; then
        local date
        for date in `sort -u -k1,1 $logfile | tail -n3 | awk '{print $1}'`; do
            [ "$regexp" ] && regexp="$regexp|^$date" || regexp="^$date"
        done
    fi

    if grep -qiE "$regexp" "$logfile"; then
        grep -iE "$regexp" "$logfile" | log_color_filter
    else
        echo No log entries ${HOST:+on remote host $HOST }matched \'$regexp\'.
    fi
    [ "$tmpfile" ] && rm -f "$tmpfile"

    return 0
}

################################################################################
# List management functions
# Bourne-shell lacks support for arrays.
# These functions support management of property values in a single variable.
# List elements/values are always separated by newlines.
################################################################################
_ORIG_IFS="$IFS"
reset_IFS() {
    IFS="$_ORIG_IFS"
}
newline_IFS() {
    IFS='
'
}
list_append() {
    local name element current_list
    name="$1"
    element="$2"

    eval "current_list=\$$name"
    if [ -z "$current_list" ]; then
        current_list="$element"
    else
        current_list="$current_list
$element"
    fi
    eval "$name=\$current_list"
}
list_append_no_duplicates() {
    local name element current_list
    name="$1"
    element="$2"

    eval "current_list=\$$name"
    if [ -z "$current_list" ]; then
        current_list="$element"
    else
        local IFS e
        IFS='
'
        for e in $current_list; do [ "$e" = "$element" ] && return 1; done
        current_list="$current_list
$element"
    fi
    eval "$name=\$current_list"
}

LIST_RETVAL=
list_get() {
    local name index current_list
    name="$1"
    index="$2"
    [ -z "$index" ] && return 1 # no value for index
    LIST_RETVAL= # clear any old value
    eval "current_list=\$$name"
    local IFS
    IFS='
'
    local count=0 e
    for e in $current_list; do
        if [ $count -eq $index ]; then
            LIST_RETVAL=$e
            return 0
        fi
        count=$((count+1))
    done
    return 1
}
list_elements() {
    local name
    name="$1"
    eval "LIST_RETVAL=\$$name"
}
list_size() {
    local name current_list
    name="$1"
    eval "current_list=\$$name"
    local IFS
    IFS='
'
    local count=0
    for element in $current_list; do count=$((count+1)); done
    LIST_RETVAL=$count
}


####################################################
# Functions for managing parsed configuration values
####################################################
add_item() {
    eval "[ \"\$CONF_ITEM_$1\" ]" && return 1 # item already registered ..
    eval "CONF_ITEM_$1=1" # register
    list_append CONF_ITEM_LIST "$1"
}
list_items() {
    list_elements CONF_ITEM_LIST
    echo "$LIST_RETVAL"
}
have_item() {
    eval "[ \"\$CONF_ITEM_$1\" ]"
}
have_items() {
    [ "$CONF_ITEM_LIST" ]
}
add_property_value() {
    local category id prop value
    category="$1" id="$2" prop="$3" value="$4"
    list_append "CONF_PROP_${category}_${id}_${prop}" "$value"
}
add_property_value_no_duplicates() {
    local category id prop value
    category="$1" id="$2" prop="$3" value="$4"
    list_append_no_duplicates "CONF_PROP_${category}_${id}_${prop}" "$value"
}
list_property_values() {
    local category id prop
    category="$1" id="$2" prop="$3"
    list_elements "CONF_PROP_${category}_${id}_${prop}"
    echo "$LIST_RETVAL"
}
property_values_exist() {
    local category id prop
    category="$1" id="$2" prop="$3"
    eval "[ \"\$CONF_PROP_${category}_${id}_${prop}\" ]"
}

# Group management
add_item_to_group() {
    list_append_no_duplicates "CONF_GROUP_${1}_ITEMS" "$2"
    list_append_no_duplicates "CONF_GROUPS" "$1"
}
list_groups() {
    list_elements "CONF_GROUPS"
    echo "$LIST_RETVAL"
}
have_groups() {
    [ "$CONF_GROUPS" ]
}
list_group_items() {
    list_elements "CONF_GROUP_${1}_ITEMS"
    echo "$LIST_RETVAL"
}
is_group() {
    eval "[ \"\$CONF_GROUP_${1}_ITEMS\" ]"
}

# Config flag management
set_global_flag_true() {
    local flag
    flag=$1
    eval "GLOBAL_CONF_FLAG_${flag}=1"
}
set_global_flag_false() {
    local flag
    flag=$1
    eval "GLOBAL_CONF_FLAG_${flag}=0"
}
global_flag_value() {
    local flag
    flag=$1
    eval "[ \"\$GLOBAL_CONF_FLAG_${flag}\" ] && [ 1 -eq \$GLOBAL_CONF_FLAG_${flag} ]"
}

set_item_flag_true() {
    local item flag
    item=$1
    flag=$2
    eval "CONF_${item}_FLAG_${flag}=1"
}
set_item_flag_false() {
    local item flag
    item=$1
    flag=$2
    eval "CONF_${item}_FLAG_${flag}=0"
}
item_flag_value() {
    local item flag
    item=$1
    flag=$2
    eval "[ \"\$CONF_${item}_FLAG_${flag}\" ] && [ \$CONF_${item}_FLAG_${flag} -eq 1 ]"
}
item_has_flag() {
    local item flag
    item=$1
    flag=$2
    eval "[ \"\$CONF_${item}_FLAG_${flag}\" ]"
}
# Effective value means taking global value into consideration.
item_flag_effective_value() {
    local item flag
    item=$1
    flag=$2
    if item_has_flag $item $flag; then
        item_flag_value $item $flag
    else
        global_flag_value $flag
    fi
}

# Word tokenizer for config file. Tokens are separated by newlines, and
# syntactically significant newlines are represented by token '<<<EoS>>>'
# (EndofStanza). Supports quoted words, quote-escaping and comment removal.
readonly EOS='<<<EoS>>>'
token_stream() {
    awk '
      BEGIN { FS=""; }
      /^[ 	]*[^ 	]/ {
          for (i=1; i<=NF; i++) {
              if (esc) { word = word $i; esc=0; continue; }
              if ($i == "#" && !iq) { if (word) {print word; word=""; } print "'"$EOS"'"; next; }
              if ($i == "\\") {
                  esc=1;
              } else if ($i == "\"" || $i == "'\''") {
                  if (iq) {
                      if (iq == $i) {
                          if (word) print word;
                          word="";
                          iq="";
                      } else {
                          word = word $i;
                      }
                  } else {
                      iq=$i;
                  }
              } else if ($i == " " || $i == "\t") {
                  if (iq) {
                      word = word $i;
                  } else {
                      if (word) print word;
                      word="";
                  }
              } else {
                  word = word $i;
              }
          }
          if (word) print word;
          word="";
          print "'"$EOS"'";
      }' "$1"
}

parse_is_flag_arg_true() {
    case $1 in
        "") return 0 ;;
        [Yy]es | YES | 1 | [tT]rue | TRUE | [Oo]n | ON) return 0 ;;
    esac
    return 1
}

################################################################################
# Nice and simple, but lenient config parser which does all the things a user
# expects.
# Allows comments (also inline), good white-space handling, quote handling
# and checks syntax and validity.
################################################################################
parse_configuration() {
    local config_file
    config_file="$1"

    if [ ! -f "$config_file" ]; then
        print_err "Configuration file not found: $config_file"
        return 1
    fi

    local IFS token keyword values firstval val
    newline_IFS
    for token in `token_stream "$config_file"`; do
        if [ "$token" != "$EOS" ]; then
            if [ "$keyword" ]; then
                list_append values "$token"
            else
                keyword="$token"
            fi
            continue
        fi

        [ "$keyword" ] || { values=; continue; }
        [ "$values" ] && { list_get values 0; firstval=$LIST_RETVAL; }

        case $keyword in
            default_host)
                if [ "$CURRENT_ITEM" ]; then
                    print_err "Config: global option '$keyword' cannot be put in item context"
                    return 1
                fi
                if [ -z "$firstval" ]; then
                    print_err "Config: global option '$keyword' requires a value"
                    return 1
                fi

                CONF_GLOBAL_DEFAULT_HOST=$firstval
                ;;
                
            item)
                if ! echo $firstval|grep -Eq '^[a-zA-Z0-9_]+$'; then
                    print_err "Config: Illegal or empty item name: $firstval"
                    return 1
                elif echo $firstval|grep -iEq '^(to|from|default|with|example|items|item|edit)$'; then
                    print_err "Config: Illegal item name: $firstval (reserved)"
                    return 1
                fi

                CURRENT_ITEM=$firstval
                add_item "$CURRENT_ITEM"
                ;;
            
            dir|dirs|directory|directories|file|files)
                if [ -z "$CURRENT_ITEM" ]; then
                    print_err "Config: encountered $keyword keyword in global context (no corresponding item)"
                    return 1
                fi
                if [ -z "$values" ]; then
                    print_err "Config (item $CURRENT_ITEM): $keyword keyword missing argument(s)"
                    return 1
                fi
                
                list_elements values
                for val in $LIST_RETVAL; do
                    if { [ "$keyword" = dir ] || [ "$keyword" = dirs ]; } && [ "${val%/}" = "$val" ]; then
                        val="$val/"
                    fi
                    add_property_value ITEM "$CURRENT_ITEM" FILES "$val"
                done
                ;;

            dconf)
                if [ -z "$CURRENT_ITEM" ]; then
                    print_err "Config: encountered $keyword keyword in global context (no corresponding item)"
                    return 1
                fi
                if [ -z "$values" ]; then
                    print_err "Config (item $CURRENT_ITEM): $keyword keyword missing argument(s)"
                    return 1
                fi
                list_elements values

                for val in $LIST_RETVAL; do
                    add_property_value ITEM "$CURRENT_ITEM" DCONF_TREES "$val"
                done
                ;;

            kill)
                if [ -z "$CURRENT_ITEM" ]; then
                    print_err "Config: encountered $keyword keyword in global context (no corresponding item)"
                    return 1
                fi
                if [ -z "$values" ]; then
                    print_err "Config (item $CURRENT_ITEM): $keyword keyword missing argument(s)"
                    return 1
                fi
                list_elements values
                for val in $LIST_RETVAL; do
                    add_property_value ITEM "$CURRENT_ITEM" KILLS "$val"
                done
                ;;

            cond|precondition)
                if [ -z "$CURRENT_ITEM" ]; then
                    print_err "Config: encountered $keyword keyword in global context (no corresponding item)"
                    return 1
                fi
                if [ -z "$values" ]; then
                    print_err "Config (item $CURRENT_ITEM): $keyword keyword missing argument(s)"
                    return 1
                fi
                list_elements values
                for val in $LIST_RETVAL; do
                    add_property_value ITEM "$CURRENT_ITEM" CONDS "$val"
                done
                ;;
            
            rsync_options|rsync_opts|rsync_opt|rsync_option)
                if [ -z "$CURRENT_ITEM" ]; then
                    print_err "Config: encountered $keyword keyword in global context (no corresponding item)"
                    return 1
                fi
                if [ -z "$values" ]; then
                    print_err "Config (item $CURRENT_ITEM): $keyword keyword missing argument(s)"
                    return 1
                fi
                list_elements values
                for val in $LIST_RETVAL; do
                    add_property_value ITEM "$CURRENT_ITEM" RSYNC_OPTS "$val"
                done
                ;;

            group)
                if [ -z "$CURRENT_ITEM" ]; then
                    print_err "Config: encountered $keyword keyword in global context (no corresponding item)"
                    return 1
                fi
                if echo $firstval|grep -Eqi '^default$'; then
                    firstval=default # normalize default group name
                elif ! echo $firstval|grep -Eq '^[a-zA-Z0-9_]+$'; then
                    print_err "Config: Illegal or empty group name: $firstval"
                    return 1
                elif echo $firstval|grep -iEq '^(to|from|example|items|item|edit|with)$'; then
                    print_err "Config: Illegal group name: $firstval (reserved)"
                    return 1
                fi

                add_item_to_group "$firstval" "$CURRENT_ITEM"
                ;;

            # Config flags (true or false)
            always_ask | target_deletes | force_update | ask_before_kill | max_mtime_check)
                if parse_is_flag_arg_true $firstval; then
                    [ "$CURRENT_ITEM" ] && set_item_flag_true "$CURRENT_ITEM" $keyword || set_global_flag_true $keyword
                else
                    [ "$CURRENT_ITEM" ] && set_item_flag_false "$CURRENT_ITEM" $keyword || set_global_flag_false $keyword
                fi
                ;;

            *)
                print_err "Config${CURRENT_ITEM:+ (item $CURRENT_ITEM)}: unknown keyword: $keyword"
                return 1
                ;;
        esac
        keyword= values= firstval= val=
    done

    # Validate group names
    local group
    for group in `list_groups`; do
        if eval "[ \"\$CONF_ITEM_$group\" ]"; then
            print_err "Config: group name '$group' conflicts with an existing item name"
            return 2
        fi
    done
}

do_command_conf_example() {
    cat <<EOF
# Complete example of ~/$CONFIG_FILE
# VERSION=6
#

# Set the default host / sync partner:
default_host otherlaptop

# Or you can set default host in the environment variable 'DS_DEFAULT_HOST'
# so you don't have to keep host-specifics in the config file.

# Hostnames can also be specified with "user@" first:
# default_host 'me@otherlaptop.my.domain'

# Uncomment this to globally disable default behaviour of forcing target updates:
#force_update false

# Uncomment this to globally disable default behaviour of deleting files at target
# which have been deleted at source:
#target_deletes false

# Uncomment this to trigger interactive confirmation before syncing for all items:
#always_ask true

# Uncomment this execute item process kills without any confirmation by default:
#ask_before_kill false

# Start sync item definitions:

item Foo                                          # an item named Foo
    files foofile1 foofile2                       # add files 'foofile1' and foofile2 to sync item, relative to your home directory.
    dir foodir1/                                  # add directory 'foodir1', directories are always synchronized recursively.
    dir foodir2                                   # add another directory 'foodir2'

item Bar                                          # another item named Bar
    file "a file with spaces.txt"                 # file names with spaces must be quoted
    dir /site/bar/                                # absolute path to a directory is allowed
    group default                                 # Add item to 'default' item group, which is a special group that is synced if no other
                                                  # items or groups are specified on the command line.

# Now some real apps and data:

item Firefox
     directory .mozilla/                             # Firefox profiles
     kill "^(/usr/lib/firefox-[0-9\.]+/)?firefox ?"  # Killing any running Firefox before sync is important.
                                                  # The kill pattern is a regular expression which should 
                                                  # match the command you want killed.
     ask_before_kill false                        # Don't ask if we want to kill any running, just do it.

item Shotwell
     directory .shotwell                                 # Shotwell data files
     dconf /apps/shotwell/                               # Shotwell configuration data
     kill 'shotwell' 
     kill 'something-else'                               # Multiple kill statements per item allowed
     always_ask true                                     # Always ask interactively before syncing this particular item


# A secure file system mounted ontop of an encrypted file:
item SecureFS
     file .securefs

     # Preconditions are small snippets of shell code expressions which 
     # must evaluate to true for the item sync to proceed. In this case,
     # we must never sync the file if a file system is mounted on top of it
     # (could corrupt file system at target):

     cond '! grep -q securefs /proc/mounts || { echo Warning: SecureFS is mounted locally \!; false; }'

     # HOST variable will always be set to remote host of sync
     # SSH_OPTS will be set to options for ssh, which includes master control socket info.
     # (so in this case we can also check if it is mounted remotely):
     cond '! ssh \$SSH_OPTS \$HOST grep -q securefs /proc/mounts || { echo Warning: SecureFS is mounted on remote host \$HOST \!; false; }'

     # Need rsync checksum-comparison for this file (timestamp is never updated, even if content changes), also be verbose:
     rsync_options -c -vv


item Emacs
      files .emacs  .elisp/      # ok to specify multiple files per line (yes, directories are OK for the 'files' keyword).
      group default

# Miscellaneous desktop stuff
item MiscDesktop              
    dirs  .icons/  .sounds/ .avatars/

    # Makes a two-way sync possible (push, then fetch or vice-versa):
    target_deletes  false            # Override/disable global option 'target_deletes' only for this item.
    force_update   false             # Override/disable gloabl option 'force_update' for only this item.
    group desktop                    # Add item to 'desktop' group, and to 'default' group
    group default

item FontConfig
    directory  .fonts/
    file .fonts.conf
    group desktop

# The ds shell script itself:
item ds
file bin/ds
max_mtime_check   # Do a max mtime check on source and destination before sync starts. The check
                  # operaties recursively on directories. If maximum mtime on destination is higher
                  # than source, then prompt for confirmation before syncing.
                  # This check will slow down syncing, but can help accidentally overwriting
                  # something newer with something older. It's the same check used by the
                  # 'stat' command to determine likely status of item locally vs remotely.
                  # This option may also be set globally for all items.

item SSHConfig
  file .ssh/config
  force_update 0  # Override/disable global option 'force_update' only for this item.

# End of file.
EOF
}


################################################################################
# Execute command bashcomp
#
# Generates BASH completion code.
################################################################################
do_command_bashcomp() {
    print "# `basename $0` context sensitive command line auto-completion (Bash)"
    print "# generated by `basename $0` v$VERSION"
    print "__DS_CMD=\"$INVOKEDIR/`basename $0`\""
    cat <<"EOF"
_ds_completion_hosts() {
    # Use _known_hosts completion from standard Bash completion package if exists
    if [ "$(type -t _known_hosts)" = function ]; then
        _known_hosts
    else
        # Fall back to simplistic parsing of ~/.ssh/config ..
        local sshosts=()
        if [ -f ~/.ssh/config ]; then
            sshosts=($(awk '/^[ 	]*[Hh]ost[ 	]/ { for (i=2; i<=NF; i++)
                                 { if (!match($i,"[][*?!]")) printf("%s ",$i);}}' < ~/.ssh/config))
        fi
        COMPREPLY=($(compgen -W "${sshosts[*]}" -- $cur))
    fi
}
_ds_completion() {
    COMPREPLY=()
    local commands="push fetch stat conf log bashcomp"
    local options="-c -Y -i -v -z -n -l -u -V -h -H"
    local prev=${COMP_WORDS[COMP_CWORD-1]} cur=${COMP_WORDS[COMP_CWORD]} pcommand pargs w_idx=0 c_idx=
    for word in "${COMP_WORDS[@]}"; do
        case $word in
            -*|'') : ;;
            *) if [ -z "$pcommand" ] && [ $w_idx -gt 0 ]; then
                   pcommand=$word
                   c_idx=$w_idx
               else
                   pargs="$pargs $word"
               fi
               ;;
        esac
        w_idx=$((w_idx+1))
    done

    COMPREPLY=($(compgen -W "$options" -- $cur))
    if [ -z "$c_idx" ] || [ $COMP_CWORD -le $c_idx ]; then
        COMPREPLY+=($(compgen -W "$commands" -- $cur))
    else
        case $pcommand in
            push|fetch)
                if [ "$prev" = to ] || [ "$prev" = from ]; then
                    _ds_completion_hosts
                else
                    [ "$pcommand" = fetch ] && local tofrom=from || local tofrom=to
                    COMPREPLY+=($(compgen -W "$($__DS_CMD __compitems $pargs) $tofrom" -- $cur))
                fi
            ;;
            stat)
                if [ "$prev" = with ]; then
                     _ds_completion_hosts
                else
                    COMPREPLY+=($(compgen -W "$($__DS_CMD __compitems $pargs) with" -- $cur))
                fi
            ;;
            conf)
                COMPREPLY+=($(compgen -W "$($__DS_CMD __compitems $pargs) example items edit" -- $cur))
            ;;
            log)
                if [ "$prev" = remote ]; then
                     _ds_completion_hosts
                elif [ "$prev" = match ]; then
                    COMPREPLY=($(compgen -W "$($__DS_CMD __compitems)" -- $cur))
                else
                    COMPREPLY+=($(compgen -W "match clear lastop remote" -- $cur))
                fi
            ;;
        esac
    fi
}
EOF
    print "complete -F _ds_completion $(basename $0)"
    print '# End of ds command line auto-completion code.'
}

do_command_conf_items() {
    if have_items; then
        if [ "$1" ]; then
            # Print details for each item or group
            local x
            for x in $*; do
                if is_group $x; then
                    local items item
                    items=`list_group_items $x`
                    print -n "Group "; print_magenta -n "$x: "
                    print_cyan $items
                    for item in $items; do
                        conf_print_item $item
                        print
                    done
                elif have_item $x; then
                    conf_print_item $x
                else
                    print_err "Unknown item or group: $x"
                fi
                print
            done
            return 0
        fi
        
        print_green 'Items: '
        print_cyan " " `list_items`
        if have_groups; then
            print
            print_green "Item groups:"
            local group
            for group in `list_groups`; do
                print_magenta -n "  $group"
                print -n ': '; print_cyan `list_group_items $group`
            done
            print
        fi
    else
        print 'No items are configured.'
    fi
}

do_command_conf_edit() {
    local tmpfile
    tmpfile=`mktemp -t ds.conf.XXXXXX` || {
        print_err "Failed to create temporary file."
        return 1
    }
    cp "$HOME/$CONFIG_FILE" "$tmpfile"
    ${EDITOR:-vi} "$tmpfile" || {
        print_err "Editor failed."
        rm -f "$tmpfile"
        return 1
    }
    # Validate config file
    local save=1 ans
    while ! parse_configuration "$tmpfile"; do
        save=
        read -p "New config did not parse correctly. [E]dit, [s]ave anyway or [d]iscard ? [E/s/d] " ans
        case $ans in
            s) save=1; break ;;
            d) break ;;
            [eE]*|"")
                ${EDITOR:-vi} "$tmpfile" || {
                    print_err "Editor failed."
                    rm -f "$tmpfile"
                    return 1
                }
                save=1
                ;;
        esac
    done
    if [ "$save" ]; then
        if ! diff "$HOME/$CONFIG_FILE" "$tmpfile" 1>/dev/null 2>&1; then
            cp "$tmpfile" "$HOME/$CONFIG_FILE"
            print "Saved."
        else
            print "No changes."
        fi
    else
        print_warn "Edits discarded."
    fi
    rm -f "$tmpfile"
}

conf_print_item() {
    local item
    item="$1"
    
    local IFS
    IFS='
'
    print -n "Item "; print_cyan "$item"
    local file kill cond tree
    for file in `list_property_values ITEM $item FILES`; do
        print "  $file"
    done

    for tree in `list_property_values ITEM $item DCONF_TREES`; do
        print_yellow -n "  dconf tree  "; print "$tree"
    done

    for kill in `list_property_values ITEM $item KILLS`; do
        print_red -n "  Kill "
        print -n "processes matching  '$kill'"
        if item_has_flag $item ask_before_kill; then
            ! item_flag_value $item ask_before_kill && print -n " (NO confirmation)"
        fi
        print
    done

    for cond in `list_property_values ITEM $item CONDS`; do
        print "  Precondition:	'$cond'"
    done

    if property_values_exist ITEM $item RSYNC_OPTS; then
        print -n "  Extra rsync options:	"
        for opt in `list_property_values ITEM $item RSYNC_OPTS`; do
            print -n "$opt "
        done
        print
    fi

    local itemopts=
    if item_has_flag $item force_update; then
        if item_flag_value $item force_update; then
            itemopts="${itemopts:+$itemopts, }force_update true"
        else
            itemopts="${itemopts:+$itemopts, }force_update false"
        fi
    fi

    if item_has_flag $item target_deletes; then
        if item_flag_value $item target_deletes; then
            itemopts="${itemopts:+$itemopts, }target_deletes true"
        else
            itemopts="${itemopts:+$itemopts, }target_deletes false"
        fi
    fi

    if item_has_flag $item always_ask; then
        if item_flag_value $item always_ask; then
            itemopts="${itemopts:+$itemopts, }always_ask true"
        else
            itemopts="${itemopts:+$itemopts, }always_ask false"
        fi
    fi
    
    if item_has_flag $item max_mtime_check; then
        if item_flag_value $item max_mtime_check; then
            itemopts="${itemopts:+$itemopts, }max_mtime_check true"
        else
            itemopts="${itemopts:+$itemopts, }max_mtime_check false"
        fi
    fi

    if [ "$itemopts" ]; then
        print_green -n "  Options: ";print "$itemopts"
    fi
}

do_command_conf() {
    if [ "$CONF_GLOBAL_DEFAULT_HOST" ]; then
        print_green -n "Default sync partner: "; print "$CONF_GLOBAL_DEFAULT_HOST"
        print
    fi

    local globalopts=
    if ! global_flag_value force_update; then
        globalopts="${globalopts:+$globalopts, }force_update false"
    fi
    if ! global_flag_value target_deletes; then
        globalopts="${globalopts:+$globalopts, }target_deletes false"
    fi
    if ! global_flag_value ask_before_kill; then
        globalopts="${globalopts:+$globalopts, }ask_before_kill false"
    fi
    if global_flag_value always_ask; then
        globalopts="${globalopts:+$globalopts, }always_ask true"
    fi
    if global_flag_value max_mtime_check; then
        globalopts="${globalopts:+$globalopts, }max_mtime_check true"
    fi
    if [ "$globalopts" ]; then
        print_green "Global options:"
        print "  $globalopts"
        print
    fi

    if ! have_items; then
        print "No items are configured."
        return 0
    fi

    if have_groups; then
        print_green "Item groups:"
        for group in `list_groups`; do
            print_magenta -n "  $group"
            print -n ': '; print_cyan `list_group_items $group`
        done
        print
    fi
    
    print_green 'Configured items:'

    local IFS
    newline_IFS
    for item in `list_items`; do
        conf_print_item $item
        print
    done
}

usage() {
    print "ds v$VERSION"
    print
    print "ds is a command line tool for manual, but quick and easy one-way syncing/mirroring"
    print "of data to/from remote hosts. It primarily uses rsync(1) and ssh(1) to accomplish"
    print "its tasks. dconf sync requires a typical Linux desktop installation (optional)."
    print
    print -n "Use: `basename $0`"; print_green -n " [options] "
    print_cyan -n "COMMAND"
    print " [command-args]"
    print
    print "Commands:"
    print_cyan -n "push  "
    print "[to [USER@]HOST] [ITEM1 ITEM2 GROUP3 [..]]"
    print "      Synchronize by pushing items to remote host."
    print
    print_cyan -n "fetch "
    print "[from [USER@]HOST] [ITEM1 ITEM2 GROUP3 [..]]"
    print "      Synchronize by fetching items from remote host."
    print
    if [ "$1" ]; then
        print -n "      If no host is specified for "; print_cyan -n push; print -n " or "; print_cyan -n fetch; 
        print " the configured default-"
        print "      host will be used."
        print -n "      If no items are specified for "; print_cyan -n push; print -n " or "; print_cyan -n fetch
        print ", then all items in the 'default' group are processed."
        print "      Specified item or group names are matched case-insensitively and you can use simple"
        print "      regular expressions, like in grep(1). When specifying a group, then all items"
        print "      in that group are processed."
        print
        print "      The standard behaviour of ds is to mirror the source at the target."
        print "      This implies two important things:"
        print "      1) If a file has been deleted from a directory tree at the source, it will"
        print "         also be deleted at the target."
        print "      2) Even files that are newer at the target will be update from source files."
        print
        print "      This behaviour ensures consistent/identical data on both ends after"
        print "      a sync, which is suitable for application configuration directories, etc."
        print
        print "      If you would like to do two-way syncing for some items, you can override this"
        print "      default behaviour by setting the options 'target_deletes' and 'force_update'"
        print "      to false in the item configuration. You can then accomplish two-way syncing"
        print -n "      by first doing a 'push', then a 'fetch'. Or you can supply the "; print_green -n "option "; print "'-u'"
        print "      when invoking ds from the command line, which will enable this behaviour"
        print "      (and override anything set in config) for that run."
        print
    fi
    print_cyan -n "log   "
    print "[all] [match REGEXP] [clear] [lastop] [remote [[USER@]HOST]]"
    print "      Shows  entries from the local (or remote) log file."
    if [ "$1" ]; then
        print "      By default, only entries for the last three logged days are shown."
        print "      You can optionally specify 'all', which will show all entries, or 'match REGEXP',"
        print "      which will show all entries matching a given regular expression"
        print "      (matching is case-insensitive)."
        print "      If 'clear' is specified, then the log file is cleared of all entries."
        print "      If 'lastop' is specified, then the last logged operation for each item or group is shown."
        print "      If a remote host is specified, then the log on that host is operated upon."
    fi
    print
    print_cyan -n "stat  "
    print "ITEM1 ITEM2 GROUP3 [with [USER@]HOST]"
    print "      Show a simple synchronization status for each item with remote host."
    if [ "$1" ]; then
        print "      If HOST is omitted, then the default sync partner host will be used."
        print "      Only status of regular files/dirs can be checked. Other types,"
        print "      such dconf, will be ignored. The status check does the following:"
        print "      For each item:"
        print "        1. Find most most recent mtime for remote and local files."
        print "        2. Check if rsync would update any existing remote files on push."
        print "        3. Check if rsync would update any existing local files on fetch."
        print "        4. Report status."
    fi
    print
    print_cyan -n "conf  "; print "[example] [items] [edit] [ITEM or GROUP ..]"
    print "      Parses and prints current configuration."
    if [ "$1" ]; then
        print "      If 'example' is specified, then an example configuration file"
        print "      is printed to standard out. If 'items' is specified, then only"
        print "      item names and groups are listed. Otherwise, arguments are assumed"
        print "      to be item or group names for which config should be printed."
        print "      If 'edit' is specified, then open EDITOR on config file."
    fi
    print
    print_cyan "bashcomp"
    print "      This special command emits BASH script code for supporting ds"
    print "      command line auto-completion. You can put the output in a file and"
    print "      source it from ~/.bashrc or equivalent."
    print
    print_green "Options:"
    print "-i    Ask before syncing each item."
    print "-Y    Automatically answer YES to all interactive questions."
    print "-z    Use compression for data-transfers to/from remote host."
    print "-u    Disable options 'force_update' and 'target_deletes'"
    print "      for all items regardless of what is set in config."
    print "-n    Enable dry-run mode. Useful to see what rsync would do."
    print "-l    Do not update any log files."
    print "-c    Enable colors in terminal output."
    print "-v    Display verbose output."
    print "-V    Show version."
    print "-h    This help."
    print "-H    Show detailed help/manual."
    exit 255
}

trap 'echo && echo Interrupted, quitting. && exit 255' INT

version() {
    echo "ds $VERSION"
    exit 0
}

##############################
# Global variables and options
##############################
GLOPT_YES=
GLOPT_INT=
GLOPT_VERB=
GLOPT_COMP=
GLOPT_COLORS=
GLOPT_DRYRUN=
GLOPT_NOLOG=
GLOPT_ONLY_UPDATE=
cmdargs=
while [ "$1" ]; do
    while getopts ":cYivznluVhH" opt; do
        case $opt in
            c) GLOPT_COLORS=1 ;;
            Y) GLOPT_YES=1 ;;
            i) GLOPT_INT=1 ;;
            v) GLOPT_VERB=1 ;;
            z) GLOPT_COMP=1 ;;
            n) GLOPT_DRYRUN=1 ;;
            l) GLOPT_NOLOG=1 ;;
            u) GLOPT_ONLY_UPDATE=1 ;;
            V) version ;;
            h) usage ;;
            H) usage detailed ;;
            \?) print_err "Invalid option: '$1'"; usage ;;
        esac
    done
    shift $((OPTIND-1))
    OPTIND=1
    [ $# -gt 0 ] && list_append cmdargs "$1" && shift
done
list_elements cmdargs
newline_IFS
set -- $LIST_RETVAL
reset_IFS

unset CURRENT_ITEM
CONF_GLOBAL_DEFAULT_HOST=$DS_DEFAULT_HOST
set_global_flag_true  target_deletes
set_global_flag_true  force_update
set_global_flag_false always_ask
set_global_flag_true  ask_before_kill
set_global_flag_false max_mtime_check

COMMAND=
SELECTED_ITEMS=
HOST=
LOG_CLEAR=
LOG_REMOTE=
LOG_REGEXP=
LOG_ALL=
LOG_LASTOP=

# Set basedir to HOME
INVOKEDIR=`pwd`
[ -d "$HOME" ] && cd "$HOME" || {
    print_err "Could not chdir to HOME dir $HOME"
    exit 1
}

# Parse, validate and execute command line
[ -z "$1" ] && usage
COMMAND=$1
shift
case "$COMMAND" in
    push|fetch|stat)
        parse_configuration "$HOME/$CONFIG_FILE"
        retcode=$?
        if [ $retcode -ne 0 ]; then
            print_err "Failed to parse configuration."
            exit $retcode
        fi
        
        if ! have_items; then
            print_err "You have not configured any items."
            exit 2
        fi

        if [ "$1" ]; then
            while [ "$1" ]; do
                case $1 in
                    to|from)
                        if { [ "$1" = "to" ] || [ "$1" = "TO" ] || [ "$1" = "To" ]; } && [ "$COMMAND" = fetch ]; then
                            print_err "Cannot \"fetch to\" a host, did you mean \"fetch from ..\" ?"
                            usage
                        fi

                        if { [ "$1" = "from" ] || [ "$1" = "FROM" ] || [ "$1" = "From" ]; } && [ "$COMMAND" = push ]; then
                            print_err "Cannot \"push from\" a host, did you mean \"push to ..\" ?"
                            usage
                        fi
                        if [ -z "$2" ]; then
                            print_err "No [USER@]HOST specified after 'from' or 'to'."
                            usage
                        fi
                        HOST="$2"
                        shift
                        ;;
                    with)
                        if [ $COMMAND != stat ]; then
                            print_err "Keyword 'with' can only be used with stat command."
                            usage
                        fi
                        if [ -z "$2" ]; then
                            print_err "No [USER@]HOST specified after 'with'."
                            usage
                        fi
                        HOST="$2"
                        shift
                        ;;
                    *)
                        SELECTED_ITEMS="$SELECTED_ITEMS $1"
                        ;;
                esac
                shift
            done
        fi

        if [ -z "$HOST" ]; then
            if [ -z "$CONF_GLOBAL_DEFAULT_HOST" ]; then
                print_err "No [USER@]HOST specified and no default host configured."
                usage
            else
                HOST=$CONF_GLOBAL_DEFAULT_HOST
            fi
        fi

        if [ -z "$SELECTED_ITEMS" ]; then
            if ! is_group default; then
                print_err "No items selected, and no items have been assigned to the 'default' group."
                exit 2
            fi
            SELECTED_ITEMS=default
        fi

        # Build requested item list
        selections=
        found=
        for selected in $SELECTED_ITEMS; do
            found=
            newline_IFS
            for confitem in `list_items`; do
                if echo "$confitem"|grep -qi "^${selected}\$"; then
                    selections="$selections $confitem"
                    found=1
                    break
                fi
            done
            if [ -z "$found" ]; then
                for confgroup in `list_groups`; do
                    if echo "$confgroup"|grep -qi "^${selected}\$"; then
                        selections="$selections $confgroup"
                        found=1
                        break
                    fi
                done
            fi
            reset_IFS
            
            if [ -z "$found" ]; then
                print_warn "No configured item or group matching '$selected' was found."
            fi
        done
        
        if [ -z "$selections" ]; then
            print_err "No matching items or groups found in configuration."
            exit 2
        fi
        
        if [ $COMMAND = stat ]; then
            print "Status with remote host: $HOST"
        else
            print "Remote host: $HOST"
        fi
        print
        print "Selected items and groups: "
        for selection in $selections; do
            if is_group $selection; then
                if [ $selection = default ]; then
                    print_magenta -n "  default"
                else
                    print_cyan -n "  $selection"
                fi
                print -n ': '
                print_cyan `list_group_items $selection`
            else
                print_cyan "  $selection"
            fi
        done

        if [ "$GLOPT_DRYRUN" ] && [ $COMMAND != stat ]; then
            print
            print "Dry run only"
        fi

        CURRENT_GROUP=
        CURRENT_ITEM=
        OP=$COMMAND
        for selection in $selections; do
            if is_group $selection; then
                CURRENT_GROUP=$selection
                for item in `list_group_items $selection`; do
                    CURRENT_ITEM=$item
                    print 
                    print -n "Item ";print_cyan $CURRENT_ITEM
                    if [ $COMMAND = stat ]; then
                        do_command_stat
                    else
                        do_command_sync
                    fi
                    print
                done
            else
                CURRENT_GROUP=
                CURRENT_ITEM=$selection
                print
                print -n "Item ";print_cyan $CURRENT_ITEM
                if [ $COMMAND = stat ]; then
                    do_command_stat
                else
                    do_command_sync
                fi
                print
            fi
        done
        ;;

    conf*)
        if [ "$1" != example ] && [ "$1" != edit ]; then
            parse_configuration "$HOME/$CONFIG_FILE"
            if [ $? -ne 0 ]; then
                print_err "Failed to parse configuration."
                exit 255
            fi
        fi
        
        if [ "$1" ]; then
            if [ "$1" = example ]; then
                do_command_conf_example
            elif [ "$1" = items ]; then
                do_command_conf_items
            elif [ "$1" = edit ]; then
                do_command_conf_edit
            else
               # Assume args are item or group names to be displayed
                do_command_conf_items "$@"
            fi
        else
            do_command_conf
        fi
        ;;
        
    log)
        parse_configuration "$HOME/$CONFIG_FILE"
        if [ $? -ne 0 ]; then
            print_err "Failed to parse configuration."
            exit 255
        fi
        while [ "$1" ]; do
            case "$1" in
                all) LOG_ALL=1 ;;
                clear) LOG_CLEAR=1 ;;
                lastop) LOG_LASTOP=1 ;;
                match)
                    if [ -z "$2" ]; then
                        print_err "Missing regular expression after 'match'"
                        usage
                    fi
                    LOG_REGEXP="$2"; shift
                    ;;
                remote)
                    LOG_REMOTE=1
                    if [ -z "$2" ]; then
                        if [ -z "$CONF_GLOBAL_DEFAULT_HOST" ]; then
                            print_err "Missing '[USER@]HOST' after 'remote' and no default host configured"
                            usage
                        else
                            HOST=$CONF_GLOBAL_DEFAULT_HOST
                        fi
                    else
                        HOST=$2; shift
                    fi
                    ;;
                *)
                    print_err "Unknown argument to 'log' command: '$1'"
                    usage
                    ;;
            esac
            shift
        done
        do_command_log
        ;;

    bashcomp)
        if [ "$1" ]; then
            print_err "The 'bashcomp' command does not take any arguments."
            usage
        fi
        do_command_bashcomp
        ;;

    __compitems)
        # Private command, used by auto-completion code. Be silent and fast in general.
        parse_configuration "$HOME/$CONFIG_FILE" 1>/dev/null 2>&1 || exit 1
        retval=
        provided=
        while [ "$1" ]; do
            if is_group $1; then
                provided="$provided `list_group_items $1` $1"
            fi
            provided="$provided $1"
            shift
        done
        list_elements CONF_ITEM_LIST
        items=$LIST_RETVAL
        list_elements CONF_GROUPS
        groups=$LIST_RETVAL

        for selection in $items $groups; do
            for p in $provided; do
                [ $p = $selection ] && continue 2
            done
            retval="$retval $selection"
        done
        echo $retval
        exit 0
        ;;

    *)
        print_err "Unknown command '$COMMAND'"; usage ;;
    "")
        usage ;;
esac

exit 0

