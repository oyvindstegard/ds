#!/bin/sh
# -*- coding: utf-8 -*-
# ds
# Copyright (C) 2009-2010 Ã˜yvind Stegard <oyvind.stegard@ifi.uio.no>
###############################################################################
#                                LICENSE
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <http://www.gnu.org/licenses/>.
###############################################################################
#
# Script for easy synchronization of items between different computers.
#
# Requirements:
# - Bourne-compatible shell (sh). GNU bash not required (code should be free of
#   "bashisms"). Tested with the dash shell.
# - rsync for file/directory sync (tested with version 3.0.3)
# - ssh, preferably set up with public key authentication and ssh-agent to remote hosts
#   to avoid having to type password many times per run.
# - perl for stat command
#
# - gconftool-2 for sync of GConf-trees (optional, works only on Linux-based systems).
# - dconf for sync of dconf trees       (optional, works only on Linux-based systems).
#
# Documentation: ds -H
#                ds conf example
#
# Bugs can be reported to author:
# Ã˜yvind Stegard <oyvind.stegard@ifi.uio.no>
#
# TODO better documentation
# TODO item sync status check
#      (with some efficient heuristics for determining  actual status).
# TODO better logging of groups

# Global constants and default values.
readonly VERSION=0.9.6
readonly LOG_FILE=".ds.log"     # always relative to $HOME
readonly CONFIG_FILE=".ds.conf" # always relative to $HOME
readonly DEBUG=

# Console output functions:
# Terminal control; emit color escape sequence or reset if no args.
tty_color() {
    if [ "$GLOPT_COLORS" ] && [ -t 1 ]; then
        case "$1" in
            red)     echo -n '[0;31m'  ;;
            green)   echo -n '[0;32m'  ;;
            yellow)  echo -n '[0;33m'  ;;
            cyan)    echo -n '[01;36m' ;;
            magenta) echo -n '[01;35m'  ;;
            reset)   echo -n '[0m'     ;;
        esac
    else
        return 1
    fi
}
print() {
    echo "$@"
}
print_verbose() {
    [ "$GLOPT_VERB" ] && print "$@"
}
print_red() {
    tty_color red; print "$@"; tty_color reset
}
print_green() {
    tty_color green; print "$@"; tty_color reset
}
print_yellow() {
    tty_color yellow; print "$@"; tty_color reset
}
print_cyan() {
    tty_color cyan; print "$@"; tty_color reset
}
print_magenta() {
    tty_color magenta; print "$@"; tty_color reset
}
print_err() {
    print_red -n "E: "
    print "$@"
}
print_warn() {
    print_yellow -n "W: "
    print "$@"

}
debug() {
    [ -z "$DEBUG" ] && return 1
    print_cyan -n "D: "
    print "$@"
}

# Ask Yes/No/Quit interactively. Default answer is yes, and
# yes will be auto-answered if global GLOPT_YES-variable is set.
# If QUIT is answered, then this function will exit.
ask_ynq() {
    if [ "$GLOPT_YES" ]; then
        print "$* [Y/n/q] y"
        return 0
    fi

    local answer
    read -p "$* [Y/n/q] " answer
    case $answer in
        y*|Y*|"")    return 0 ;;
        q*|Q*)       print "Quit."; exit 2 ;;
        *)           return 1 ;;
    esac
}

ask_abort() {
    ask_ynq "$*, abort ?" && print_red "Aborted." && exit 255
}

path_escape_compatible() {
    echo "$1"|sed -e 's/\([ 	()"$#&]\)/\\\1/g' -e 's/\[/\\[/g' -e 's/\]/\\]/g'
}

max_mtime() {
    type perl 1>/dev/null 2>&1 || {
        print_err "Missing required dependency for stat command: perl"
        print_err "It has to be available somewhere in your PATH both locally and on remote host."
        return 255
    }
    
    local path paths remote=
    [ "$1" = remote ] && remote=1; shift
    while [ "$1" ]; do
        if [ "$remote" ]; then
            path=`path_escape_compatible "$1"`
        else
            path="$1"
        fi
        paths="$paths
$path"
        shift
    done
    
    # Use perl for a portable way to iterate paths recursively and determine
    # the most recently modified file or directory.
    local progtmp
    progtmp=`mktemp -t ds_max_mtime.pl.XXXXX`
    cat > $progtmp <<"EOP"
#!/usr/bin/env perl
use strict;
my $mtime_newest = 0;
my $path_newest = "";
sub traverse {
    my $path = $_[0];
    my @stats = stat($path);
    if (@stats) {
        my $mtime = $stats[9];
        if ($mtime > $mtime_newest) {
            $mtime_newest = $mtime;
            $path_newest = $path;
        }
    }
    if (-d "$path" && !(-l "$path")) {
        my $DH;
        opendir($DH, $path) or return;
        while (defined (my $entry = readdir($DH))) {
            next if ($entry eq "." || $entry eq "..");
            &traverse($path . "/" . $entry);
        }
        closedir($DH);
    }
}
foreach my $path (@ARGV) {
    &traverse($path);
}
if ($mtime_newest) {
    print "$mtime_newest\t$path_newest\n";
} else {
    exit 1;
}
EOP
    local IFS exitcode
    newline_IFS
    if [ "$remote" ]; then
        ssh $HOST perl - $paths < $progtmp
        exitcode=$?
    else
        perl $progtmp $paths
        exitcode=$?
    fi
    reset_IFS
    rm -f $progtmp
    return $exitcode
}


# Handle files and directories
# If OP is 'stat', then the following applies:
#   . Variable MAX_MTIME_REMOTE will be set to higest
#     modification timestamp found amongst remote files/dirs.
#   . Variable MAX_MTIME_REMOTE_PATH will be set to remote
#     path with highest mtime.
#   . Variable MAX_MTIME_LOCAL will be set to highest
#     modification timestamp found amongst local files/dirs.
#   . Variable MAX_MTIME_LOCAL_PATH will be set to local
#     path with highest mtime.
#
# If OP is 'push' or 'fetch', then variable ERRORS will contain any error
# messages if rsync fails.
#
# Retcode 10 if anything fails for any OP.
# Retcode 100 for invalid OP.
#
handler_file() {
    # Check that we have rsync
    type rsync 1>/dev/null 2>&1 || {
        print_err "Missing required dependency: rsync"
        print_err "It has to be available somewhere in your PATH."
        return 255
    }
    reset_IFS
    local retval oldpwd
    oldpwd=`pwd`
    cd "$HOME"                # Jump to home-directory as default base-path
    handler_file_internal "$@"
    retval=$?
    cd "$oldpwd"              # Jump back
    return $retval
}
handler_file_internal(){
    local opts relative_paths= absolute_paths= relpaths_disp=
    opts=$RSYNC_EXTRA_OPTS
    unset ERRORS CHANGES_PUSH CHANGES_FETCH

    # RSync command line opts is newline-separated. We bend over backwards to
    # properly support file names with spaces in them, while also batching
    # together all relative paths in a single rsync run to make things the most
    # efficient.

    [ "$opts" ] && print "Extra rsync options: $opts"

    [ "$GLOPT_DRYRUN" ] && opts="$opts
-n"
    [ "$GLOPT_VERB" ] && opts="$opts
-v"
    [ "$GLOPT_COMP" ] && opts="$opts
-z"
    [ "$TARGET_DELETES" ] && opts="$opts
--delete"
    [ "$FORCE_UPDATE" ] || opts="$opts
--update"

    while [ "$1" ]; do
        case $OP in
            push|stat)
                if [ "${1#/}" = "$1" ]; then
                    relative_paths="$relative_paths
$1"
                    relpaths_disp="${relpaths_disp:+$relpaths_disp, }$1"
                else
                    absolute_paths="$absolute_paths
$1"
                fi
                ;;

            fetch)
                local escaped_path
                if [ "${1#/}" = "$1" ]; then
                    escaped_path=`path_escape_compatible "$1"`
                    relative_paths="$relative_paths
$HOST:$escaped_path"
                    relpaths_disp="${relpaths_disp:+$relpaths_disp, }$1"
                    
                else
                    absolute_paths="$absolute_paths
$1"
                fi
                ;;
        esac
        shift
    done
    
    case $OP in
        stat)
            local local_max_mtime= remote_max_mtime= output retcode
            local IFS
            newline_IFS

            CHANGES_PUSH=
            if [ "$relative_paths" ]; then
                output=`rsync -aui -n --no-implied-dirs --relative $relative_paths $HOST:`
                if [ $? -ne 0 ]; then
                    print_err "rsync failed for paths: $relpaths_disp"
                    return 10
                fi
                [ "$output" ] && CHANGES_PUSH="$output"
            fi
            if [ "$absolute_paths" ]; then
                local abspath abspath_escaped
                for abspath in $absolute_paths; do
                    abspath_escaped=`path_escape_compatible "$abspath"`
                    output=`rsync -aui -n $abspath $HOST:$abspath_escaped`
                    if [ $? -ne 0 ]; then
                        print_err "rsync failed for path: $abspath"
                        return 10
                    fi
                    
                    if [ "$output" ]; then
                        if [ "$FILE_CHANGES_PUSH" ]; then
                            CHANGES_PUSH="$CHANGES_PUSH
$output"
                        else
                            CHANGES_PUSH="$output"
                        fi
                    fi
                done
            fi

            CHANGES_FETCH=
            if [ "$relative_paths" ]; then
                local relpath relpath_escaped relpaths_host=
                for relpath in $relative_paths; do
                    relpath_escaped=`path_escape_compatible "$relpath"`
                    relpaths_host="$relpaths_host
$HOST:$relpath_escaped"
                done
                output=`rsync -aui -n --no-implied-dirs --relative $relpaths_host .`
                if [ $? -ne 0 ]; then
                    print_err "rsync failed for paths: $relpaths_disp"
                    return 10
                fi
                if [ "$output" ]; then
                    CHANGES_FETCH="$output"
                fi
            fi
            if [ "$absolute_paths" ]; then
                local abspath abspath_escaped
                for abspath in $absolute_paths; do
                    abspath_escaped=`path_escape_compatible "$abspath"`
                    output=`rsync -auOi -n $HOST:$abspath_escaped $abspath`
                    if [ $? -ne 0 ]; then
                        print_err "rsync failed for path: $abspath"
                        return 10
                    fi
                    if [ "$output" ]; then
                        if [ "$CHANGES_FETCH" ]; then
                            CHANGES_FETCH="$CHANGES_FETCH
$output"
                        else
                            CHANGES_FETCH="$output"
                        fi
                    fi
                done
            fi
                    
            if [ "$CHANGES_FETCH" ] && [ "$CHANGES_PUSH" ]; then
                local paths
                if [ "$relative_paths" ]; then
                    paths="$relative_paths"
                fi
                if [ "$absolute_paths" ]; then
                    paths="$paths
$absolute_paths"
                fi
                output=`max_mtime local $paths`
                if [ $? -ne 0 ] || [ -z "$output" ]; then
                    print_err "handler_file: failed to determine max local mtime for paths: $paths"
                    return 10
                fi
                MAX_MTIME_LOCAL=`echo "$output"|cut -f1`
                MAX_MTIME_LOCAL_PATH=`echo "$output"|cut -f2-`
                
                output=`max_mtime remote $paths`
                if [ $? -ne 0 ] || [ -z "$output" ]; then
                    print_err "handler_file: failed to determine max remote mtime for paths: $paths"
                    return 10
                fi
                MAX_MTIME_REMOTE=`echo "$output"|cut -f1`
                MAX_MTIME_REMOTE_PATH=`echo "$output"|cut -f2-`
            fi                
            
            
            return 0
            ;;

        
        push)
           # NOTE: --protect-args is only compatible with newer rsync versions, stay compatible and work-around by escaping instead.
            local retcode
            if [ "$relative_paths" ]; then
                print "Pushing to remote host $HOST:" $relpaths_disp
                local IFS
                newline_IFS
                #rsync --protect-args --relative --no-implied-dirs --archive $opts $relative_paths "$HOST:." # dot(.) after HOST: is work-around for rsync-bug.
                rsync  --relative --no-implied-dirs --archive $opts $relative_paths "$HOST:"
                retcode=$?
                reset_IFS
                if [ $retcode -ne 0 ]; then
                    print_err "handler_file: rsync failed with error $retcode (path list: $relpaths_disp)"
                    ERRORS="${ERRORS:+$ERRORS, }rsync failed with error $retcode (path list: $relpaths_disp)"
                fi
            fi

            if [ "$absolute_paths" ]; then
                local abspath abspath_escape
                newline_IFS
                for abspath in $absolute_paths; do
                    print "Pushing $abspath to remote host $HOST:$abspath"
                    #rsync --protect-args --archive $opts $abspath "$HOST:$abspath" # rsync --protect-args only available in recent versions
                    abspath_escaped=`path_escape_compatible "$abspath"`
                    rsync --archive $opts $abspath "$HOST:$abspath_escaped"
                    retcode=$?
                    if [ $retcode -ne 0 ]; then
                        print_err "handler_file: rsync failed with error $retcode (path: $abspath)"
                        ERRORS="${ERRORS:+$ERRORS, }rsync failed with error $retcode (path: $abspath)"
                    fi
                done
                reset_IFS
            fi
            ;;

        fetch)
            local retcode
            if [ "$relative_paths" ]; then
                print "Fetching from remote host $HOST:" $relpaths_disp
                newline_IFS
                #rsync --protect-args --relative --no-implied-dirs --archive $opts $relative_paths .
                rsync --relative --no-implied-dirs --archive $opts $relative_paths .
                retcode=$?
                reset_IFS
                if [ $retcode -ne 0 ]; then
                    print_err "handler_file: rsync failed with error $retcode (path list: $relpaths_disp)"
                    ERRORS="${ERRORS:+$ERRORS, }rsync failed with error $retcode (path list: $relpaths_disp)"
                fi
            fi

            if [ "$absolute_paths" ]; then
                local abspath errors abspath_escaped
                newline_IFS
                for abspath in $absolute_paths; do
                    print "Fetching $abspath from remote host $HOST:$abspath"
                    #rsync --protect-args --archive $opts "$HOST:$abspath" "$abspath"
                    abspath_escaped=`path_escape_compatible "$abspath"`
                    rsync --archive $opts "$HOST:$abspath_escaped" "$abspath"
                    retcode=$?
                    if [ $retcode -ne 0 ]; then
                        print_err "handler_file: rsync failed with error $retcode (path $abspath)"
                        ERRORS="${ERRORS:+$ERRORS, }rsync failed with error $retcode (path $abspath)"
                    fi
                done
                reset_IFS
            fi
            ;;
        
        *)
            return 100
            ;;
    esac

    [ "$ERRORS" ] && return 10 || return 0
}

# Utility functions for working with local and remote DBUS sessions (required for dconf):
DBUS_REMOTE_SESSION_PID=
DBUS_REMOTE_SESSION_ADDRESS=
dbus_open_remote_session() {
    local tmpfile addr pid
    if [ "$DBUS_REMOTE_SESSION_ADDRESS" ]; then
        return 0 # a remote dbus session already available
    fi
    
    tmpfile=`mktemp`
    # Try to obtain address of any running dbus instance on remote host first
    ssh -x $HOST 'set -e;U=`id -nu`;DCPID=`pgrep -o -u $U dconf-service`;test "$DCPID" -a -f /proc/$DCPID/environ;xargs -0 -n1 -a /proc/$DCPID/environ|grep DBUS_SESSION_BUS_ADDRESS|cut -d= -f2-' > $tmpfile
    addr=`cat $tmpfile`
    if [ "$addr" ]; then
        # found already running remote session bus, use that
        DBUS_REMOTE_SESSION_ADDRESS=$addr
        DBUS_REMOTE_SESSION_PID=
        rm -f $tmpfile
        return 0
    fi

    # No running dbus session found on remote host, set up our own
    ssh -x $HOST 'dbus-daemon --session --fork --print-pid --print-address' > $tmpfile
    addr=`head -n1 $tmpfile`
    pid=`tail -n1 $tmpfile`
    if [ -z "$addr" ] || [ -z "$pid" ]; then
        print_err "dbus_open_remote_session: failed to start dbus-daemon on remote host"
        rm -f $tmpfile
        return 2
    fi
    rm -f $tmpfile

    DBUS_REMOTE_SESSION_PID=$pid
    DBUS_REMOTE_SESSION_ADDRESS=$addr
    return 0
}

dbus_close_remote_session() {
    if [ "$DBUS_REMOTE_SESSION_PID" ]; then
        # We have started a remote dbus session ourselves, kill it
        ssh -x $HOST "kill $DBUS_REMOTE_SESSION_PID 2>/dev/null" || print_warn "dbus_close_remote_session: failed to kill remotely started dbus-daemon with pid $DBUS_REMOTE_SESSION_PID"
        DBUS_REMOTE_SESSION_PID=
    fi
    DBUS_REMOTE_SESSION_ADDRESS=
}

DBUS_LOCAL_SESSION_ADDRESS=
DBUS_LOCAL_SESSION_PID=
dbus_open_local_session() {
    if [ "$DBUS_LOCAL_SESSION_ADDRESS" ]; then
        # local session already available
        return 0
    fi

    local tmpfile addr pid
    if [ -z "$DBUS_SESSION_BUS_ADDRESS" ]; then
        # no local dbus-daemon available, start one up
        tmpfile=`mktemp`
        dbus-daemon --session --fork --print-pid --print-address > $tmpfile
        if [ $? -ne 0 ]; then
            print_err "dbus_open_local_session: failed to start dbus-daemon on local host"
            rm -f $tmpfile
            return 1
        fi
        addr=`head -n1 $tmpfile`
        pid=`tail -n1 $tmpfile`
        if [ -z "$addr" ] || [ -z "$pid" ]; then
            print_err "dbus_open_local_session: failed to start dbus-daemon on local host"
            rm -f $tmpfile
            return 2
        fi
        rm -f $tmpfile
        DBUS_LOCAL_SESSION_PID=$pid
        DBUS_LOCAL_SESSION_ADDRESS=$addr
    else
        # local session already available
        DBUS_LOCAL_SESSION_ADDRESS=$DBUS_SESSION_BUS_ADDRESS
        DBUS_LOCAL_SESSION_PID=
    fi
    return 0
}

dbus_close_local_session() {
    if [ "$DBUS_LOCAL_SESSION_PID" ]; then
        kill $DBUS_LOCAL_SESSION_PID || print_warn "dbus_close_local_session: failed to kill locally started dbus-daemon"
        DBUS_LOCAL_SESSION_PID=
    fi
    DBUS_LOCAL_SESSION_ADDRESS=
}

# Handle dconf trees
handler_dconf() {
    reset_IFS

    type dconf 1>/dev/null 2>&1 || {
        print_err "Missing required dependency for dconf sync: dconf"
        print_err "It has to be available somewhere in your PATH."
        return 255
    }

    local tree="$1"
    unset ERRORS

    if [ -z "$tree" ] || [ / = "$tree" ]; then
        print_err "handler_dconf: database root '$tree' not allowed"
        ERRORS="dconf tree $tree: database root not allowed"
        return 1
    fi

    if [ "${tree%/}" = "$tree" ]; then
        # we only support trees, so add the last slash:
        tree="$tree/"
    fi

    local sshopts="-x"
    [ "$GLOPT_COMP" ] && sshopts="$sshopts -C"

    case $OP in
        push)
            # Transfer dconf tree to remote host
            print "Transferring dconf tree $tree to remote host $HOST"

            dbus_open_remote_session
            if [ $? -ne 0 ]; then
                print_err "handler_dconf: unable to acquire remote dbus session"
                return 1
            fi
            
            if [ "$GLOPT_DRYRUN" ]; then
                print "handler_dconf: dry run commands:"
                print "handler_dconf:" "dconf dump $tree | ssh $sshopts $HOST 'DBUS_SESSION_BUS_ADDRESS=$DBUS_REMOTE_SESSION_ADDRESS dconf load $tree'"
            else
                dconf dump "$tree" | ssh $sshopts $HOST "DBUS_SESSION_BUS_ADDRESS=$DBUS_REMOTE_SESSION_ADDRESS dconf load $tree"
                if [ $? -ne 0 ]; then
                    print_err "handler_dconf: failed to send data to host $HOST"
                    ERRORS="dconf tree $tree: failed to send data to host $HOST"
                    dbus_close_remote_session
                    return 1
                fi
            fi

            dbus_close_remote_session
            return 0
            ;;

        fetch)
            # Retrieve dconf tree from remote host
            print "Retrieving dconf tree $tree from remote host $HOST"

            dbus_open_local_session
            if [ $? -ne 0 ]; then
                print_err "handler_dconf: unable to acquire local dbus session"
                return 1
            fi
            
            if [ "$GLOPT_DRYRUN" ]; then
                print "handler_dconf: dry run commands:"
                print "handler_dconf:" "ssh $sshopts $HOST 'dconf dump $tree'|DBUS_SESSION_BUS_ADDRESS=$DBUS_LOCAL_SESSION_ADDRESS dconf load $tree"
            else
                ssh $sshopts $HOST "dconf dump $tree" |DBUS_SESSION_BUS_ADDRESS=$DBUS_LOCAL_SESSION_ADDRESS dconf load "$tree"
                if [ $? -ne 0 ]; then
                    print_err "handler_dconf: failed to retrieve dconf data from host $HOST"
                    ERRORS="dconf tree $tree: failed to retrieve dconf data from host $HOST"
                    dbus_close_local_session
                    return 1
                fi
            fi

            dbus_close_local_session
            return 0
            ;;
        
        *)
            return 2
            ;;
    esac
}

# Handle GConf-trees
# DEPRECATED in favour of dconf
handler_gconf() {
    reset_IFS

    # Check that we have gconftool-2 locally at least.
    type gconftool-2 1>/dev/null 2>&1 || {
        print_err "Missing required dependency for GConf-sync: gconftool-2"
        print_err "It has to be available somewhere in your PATH."
        return 255
    }

    local tree="$1"
    unset ERRORS

    if [ -z "$tree" ] || [ / = "$tree" ]; then
        print_err "handler_gconf: database root '$tree' not allowed"
        ERRORS="GConf tree $tree: database root not allowed"
        return 1
    fi

    local sshopts="-x"
    [ "$GLOPT_COMP" ] && sshopts="$sshopts -C"

    case $OP in
        push)
            # Transfer GConf tree to remote host
            print "Transferring GConf tree $tree to remote host $HOST"
            if gconftool-2 --dir-exists "$tree"; then
                if [ "$GLOPT_DRYRUN" ]; then
                    print "handler_gconf: dry run commands:"
                    print "handler_gconf:" "gconftool-2 --dump $tree | ssh $sshopts $HOST 'gconftool-2 --unload -'"
                    print "handler_gconf:" "gconftool-2 --dump $tree | ssh $sshopts $HOST 'gconftool-2 --load -; retcode=\$?; killall -HUP gconfd-2 2>/dev/null; exit \$retcode'"
                else
                    gconftool-2 --dump $tree | ssh $sshopts $HOST 'gconftool-2 --unload -'
                    gconftool-2 --dump $tree | ssh $sshopts $HOST "gconftool-2 --load -; retcode=\$?; killall -HUP gconfd-2 2>/dev/null; exit \$retcode"
                    if [ $? -ne 0 ]; then
                        print_err "handler_gconf: failed to send data to host $HOST"
                        ERRORS="GConf tree $tree: failed to send data to host $HOST"
                        return 1
                    fi
                fi
            else
                print_err "GConf tree $tree does not exist locally or error invoking gconftool-2"
                ERRORS="GConf tree $tree does not exist locally or error invoking gconftool-2"
                return 1
            fi

            return 0
            ;;

        fetch)
            # Load GConf-tree from remote host to local
            print "Retrieving GConf tree $tree from remote host $HOST .."

            if ssh $sshopts $HOST "gconftool-2 --dir-exists $tree"; then
                if [ "$GLOPT_DRYRUN" ]; then
                    print "handler_gconf: dry run commands:"
                    print "handler_gconf: ssh $sshopts $HOST 'gconftool-2 --dump $tree' > <tmpfile>"
                    print "handler_gconf: gconftool-2 --unload <tmpfile>; gconftool-2 --load <tmpfile>"
                    print "handler_gconf: killall -HUP gconfd-2"
                else
                    local tmpfile
                    tmpfile=`mktemp`
                    ssh $sshopts $HOST "gconftool-2 --dump $tree" > $tmpfile
                    if [ $? -ne 0 ]; then
                        print_err "handler_gconf: failed to retrieve GConf data from host $HOST"
                        ERRORS="GConf tree $tree: failed to retrieve data"
                        rm -f $tmpfile
                        return 1
                    fi

                    gconftool-2 --unload $tmpfile
                    gconftool-2 --load $tmpfile
                    if [ $? -ne 0 ]; then
                        print_err "handler_gconf: failed to load data into local database"
                        ERRORS="GConf tree $tree: failed to load data into local database"
                        rm -f $tmpfile
                        return 1
                    fi
                    killall -HUP gconfd-2
                    rm -f $tmpfile
                fi
            else
                print_err "handler_gconf: GConf tree $tree does not exist on remote host or error invoking gconftool-2"
                ERRORS="GConf tree $tree does not exist on remote host or error invoking gconftool-2"
                return 1
            fi

            return 0
            ;;
        *)
            return 2
            ;;
    esac
}

# Execute stat
do_command_stat() {
    local retcode
    [ -z "$CURRENT_ITEM" ] && return 1

    # Do sync status for files/dirs
    if property_values_exist ITEM $CURRENT_ITEM FILES; then
        local IFS
        newline_IFS
        handler_file `list_property_values ITEM $CURRENT_ITEM FILES`
        retcode=$?
        if [ $retcode -ne 0 ]; then
            print_red "  Unknown error"
            return 1
        fi
        echo debug: MAX_MTIME_LOCAL=$MAX_MTIME_LOCAL
        echo debug: MAX_MTIME_LOCAL_PATH=$MAX_MTIME_LOCAL_PATH
        echo debug: MAX_MTIME_REMOTE=$MAX_MTIME_REMOTE
        echo debug: MAX_MTIME_REMOTE_PATH=$MAX_MTIME_REMOTE_PATH
        
        if [ $MAX_MTIME_LOCAL -gt $MAX_MTIME_REMOTE ]; then
            print -n "<  "; print_green "Most recently updated locally."
        elif [ $MAX_MTIME_LOCAL -eq $MAX_MTIME_REMOTE ]; then
            print_green "   Looks untouched on both sides."
        else
            print -n ">  ";print_yellow "Most recently updated remotely."
        fi
    fi
}

# Execute sync
# Variable CURRENT_ITEM should hold the name of item to sync
do_command_sync() {
    local item
    item="$CURRENT_ITEM"
    [ -z "$item" ] && return 1

    print
    if item_flag_effective_value $item always_ask || [ "$GLOPT_INT" ]; then
        if [ $OP = push ] && ! ask_ynq "Push item $item to host $HOST ?"; then
            continue
        fi
        if [ $OP = fetch ] && ! ask_ynq "Fetch item $item from host $HOST ?"; then
            continue
        fi
    fi

    # Do preconditions first
    if property_values_exist ITEM $item CONDS; then
        local cond
        local IFS
        newline_IFS
        for cond in `list_property_values ITEM $item CONDS`; do
            reset_IFS
            local retval
            eval "$cond" # run cond
            retval=$?
            if [ $retval -ne 0 ]; then
                print_warn "Item pre-condition failed with exit code $retval:"; print "   $cond"; print
                ask_ynq "Do you wish to skip this item ?"
                if [ $? -eq 0 ]; then
                    continue 2
                fi
                # Continue evaluating the rest of the pre-conditions, anyway ..
            fi
        done
    fi

    # Do any kills
    unset NO_KILL_CONFIRMATION
    if property_values_exist ITEM $item KILLS; then
        if ! item_flag_effective_value $item ask_before_kill; then
            NO_KILL_CONFIRMATION=1
        fi
        newline_IFS
        ask_kill_local_remote `list_property_values ITEM $item KILLS`
        reset_IFS
    fi

    # Set any special RSync options for the item
    unset RSYNC_EXTRA_OPTS
    if property_values_exist ITEM $item RSYNC_OPTS; then
        RSYNC_EXTRA_OPTS=`list_property_values ITEM $item RSYNC_OPTS`
    fi

    # Set up any flags
    unset TARGET_DELETES
    if item_flag_effective_value $item target_deletes && [ -z "$GLOPT_ONLY_UPDATE" ]; then
        TARGET_DELETES=1
    fi

    unset FORCE_UPDATE
    if item_flag_effective_value $item force_update && [ -z "$GLOPT_ONLY_UPDATE" ]; then
        FORCE_UPDATE=1
    fi
    
    local logmsg=
    unset ERRORS # handlers populate this variable with any error messages

    # Do files/dirs
    if property_values_exist ITEM $item FILES; then
        newline_IFS
        handler_file `list_property_values ITEM $item FILES`
        if [ $? -ne 0 ]; then
            print_warn "File handler reported errors while syncing item files"
            logmsg="$ERRORS"
        else
            print_green OK
        fi
        reset_IFS
    fi

    # Do GConf-trees
    if property_values_exist ITEM $item GCONF_TREES; then
        local tree
        newline_IFS
        for tree in `list_property_values ITEM $item GCONF_TREES`; do
            reset_IFS
            handler_gconf "$tree"
            if [ $? -ne 0 ]; then
                print_warn "Sync of GConf tree $tree failed"
                logmsg="${logmsg:+$logmsg, }$ERRORS"
            else
                print_green OK
            fi
        done
    fi
    # Do dconf trees
    if property_values_exist ITEM $item DCONF_TREES; then
        local tree
        newline_IFS
        for tree in `list_property_values ITEM $item DCONF_TREES`; do
            reset_IFS
            handler_dconf "$tree"
            if [ $? -ne 0 ]; then
                print_warn "Sync of dconf tree $tree failed"
                logmsg="${logmsg:+$logmsg, }$ERRORS"
            else
                print_green OK
            fi
        done
    fi

    if [ -z "$logmsg" ]; then
        log_hook OK
    else
        log_hook "$logmsg"
    fi
}

ask_kill_local_remote() {
    reset_IFS
    local local_pids=
    local remote_pids=
    local username=$USER
    if [ "${HOST#*@*}" != "$HOST" ]; then
        username="`echo $HOST|cut -d@ -f1`"
    fi

    local pids= pid
    while [ "$1" ]; do
        pids=`pgrep -f -U $USER "$1"` && { for pid in $pids; do [ $pid -ne $$ ] && local_pids="$local_pids $pid"; done; }
        pids=`ssh -x $HOST "pgrep -f -U $username '$1'"` && { for pid in $pids; do remote_pids="$remote_pids $pid"; done; }
        shift
    done

    local_pids="${local_pids## }"
    remote_pids="${remote_pids## }"

    if [ "$local_pids" ]; then
        print_warn "Processes associated with item $CURRENT_ITEM found running locally:"
        ps -p "$local_pids" -o pid,cmd
        print
        if [ "$NO_KILL_CONFIRMATION" ]; then
            print "Killing now"
            kill $local_pids && sleep 3 || ask_abort "Failed to kill local processes associated with item $CURRENT_ITEM"
        else
            if ask_ynq "Kill them before sync ?"; then
                print "Killing now"
                kill $local_pids && sleep 3 || ask_abort "Failed to kill local processes associated with item $CURRENT_ITEM"
            fi
        fi
    fi

    if [ "$remote_pids" ]; then
        print_warn "Processes associated with item $CURRENT_ITEM found running remotely:"
        ssh -x $HOST "ps -p '$remote_pids' -o pid,cmd"
        print
        if [ "$NO_KILL_CONFIRMATION" ]; then
            print "Killing now"
            ssh -x $HOST kill $remote_pids && sleep 3 || ask_abort "Failed to kill remote processes associated with item $CURRENT_ITEM"
        else
            if ask_ynq "Kill them before sync ?"; then
                print "Killing now"
                ssh -x $HOST kill $remote_pids && sleep 3 || ask_abort "Failed to kill remote processes associated with item $CURRENT_ITEM"
            fi
        fi
    fi
}

log_date() {
    date +'%Y-%m-%d %H:%M'
}

log_hook() {
    { [ "$GLOPT_DRYRUN" ] || [ "$GLOPT_NOLOG" ]; } && return 0 # Log nothing if dry run or --nolog option.
    local message
    message=$1

    [ "$message" ] && message=", $message"
    case $OP in
        push)
            echo "`log_date` <  PUSH ${CURRENT_GROUP:+group $CURRENT_GROUP }item $CURRENT_ITEM to host $HOST$message" >> "$HOME/$LOG_FILE"

            # Update remote log file
            echo "`log_date`  > REMOTE_PUSH ${CURRENT_GROUP:+group $CURRENT_GROUP }item $CURRENT_ITEM from host `hostname`$message" |\
                 ssh -x $HOST "cat - >> $LOG_FILE"
            if [ $? -ne 0 ]; then
                print_warn "Failed to update remote log file"
            fi
            ;;

        fetch)
            echo "`log_date`  > FETCH ${CURRENT_GROUP:+group $CURRENT_GROUP }item $CURRENT_ITEM from host $HOST$message" >> "$HOME/$LOG_FILE"

            # Update remote log file
            echo "`log_date` <  REMOTE_FETCH ${CURRENT_GROUP:+group $CURRENT_GROUP }item $CURRENT_ITEM from host `hostname`$message" |\
                 ssh -x $HOST "cat - >> $LOG_FILE"
            if [ $? -ne 0 ]; then
                print_warn "Failed to update remote log file"
            fi
            ;;
    esac
}

log_color_filter() {
    if [ -z "$GLOPT_COLORS" ] || ! [ -t 1 ]; then
        while read line; do echo "$line"; done
    else
        while read date time direction op a b c d e f g h; do
            echo -n "$date $time $direction $op "
            if [ "$a" = group ]; then
                echo -n "group "
                tty_color magenta
                echo -n "$b "
                tty_color reset
                echo -n "item "
                tty_color cyan
                echo -n "$d "
                tty_color reset
                if [ "${h%OK}" != "$h" ]; then
                    echo -n "$e $f $g ${h%OK}"
                    tty_color green
                    echo OK
                    tty_color reset
                else
                    echo -n "$e $f $g "
                    tty_color red
                    echo "$h"
                    tty_color reset
                fi
            else
                echo -n "item "
                tty_color cyan
                echo -n "$b "
                tty_color reset
                rest="$f${g:+ $g}${h:+ $h}"
                if [ "${rest%OK}" != "$rest" ]; then
                    echo -n "$c $d $e ${rest%OK}"
                    tty_color green
                    echo OK
                    tty_color reset
                else
                    echo -n "$c $d $e "
                    tty_color red
                    echo "$rest"
                    tty_color reset
                fi
            fi
        done
    fi
}

do_command_log() {
    if [ -z "$HOST" ] && [ ! -f "$HOME/$LOG_FILE" ]; then
        print_warn "Log file ~/$LOG_FILE not found."
        return 1
    fi

    if [ "$LOG_LASTOP" ]; then
        local lastops_tmpfile
        lastops_tmpfile=`mktemp`
        if [ "$HOST" ]; then
            print "Last operation per configured item or group in log on remote host: $HOST"
            print
            local tmpfile
            tmpfile=`mktemp`
            ssh -x $HOST "cat $LOG_FILE" > $tmpfile
            case $? in # FIXME: duplicated error handling code (look further down).
                0|1) : ;; # OK
                2)
                    print_warn "Log file ~/$LOG_FILE not found on remote host $HOST."
                    rm -f $tmpfile
                    return 1
                    ;;
                255)
                    print_err "Could not connect to host $HOST"
                    rm -f $tmpfile
                    return 1
                    ;;
                *)
                    print_err "Unknown error while getting log file on remote host $HOST"
                    rm -f $tmpfile
                    return 1
                    ;;
            esac
            for item in `list_items`; do
                fgrep " item $item" "$tmpfile"|tail -n1 >> "$lastops_tmpfile"
            done
            
            rm -f $tmpfile
        else
            print "Last operation per configured item or group in local log"
            print
            for item in `list_items`; do
                fgrep " item $item" "$HOME/$LOG_FILE"|tail -n1 >> "$lastops_tmpfile"
            done
        fi
        sort -k1,2 "$lastops_tmpfile" | log_color_filter
        rm -f "$lastops_tmpfile"

        return 0
    fi

    if [ "$LOG_CLEAR" ]; then
        # Clear logfile requested
        if [ "$HOST" ]; then
            print "Clearing log file ~/$LOG_FILE on remote host $HOST .."
            ssh -x $HOST 'test -f $LOG_FILE'
            if [ $? -ne 0 ]; then
                print_err "Log file not found on remote host $HOST."
                return 1
            else
                ssh -x $HOST "echo -n > $LOG_FILE"
                [ $? -ne 0 ] && print_err "Failed to clear log file on remote host $HOST" && return 1
                return 0
            fi
        else
            print "Clearing log file ~/$LOG_FILE .."
            echo -n > "$HOME/$LOG_FILE"
            [ $? -ne 0 ] && print_err "Failed to clearn log file." && return 1
            return 0
        fi
    fi
    
    local regexp=
    [ "$LOG_REGEXP" ] && regexp="$LOG_REGEXP"
    [ "$LOG_ALL" ] && regexp='.'

    local tmpfile=
    local logfile="$HOME/$LOG_FILE"
    if [ "$HOST" ]; then
        tmpfile=`mktemp`
        ssh -x $HOST cat $LOG_FILE > $tmpfile
        case $? in
            0|1) : ;; # OK
            2)
                print_warn "Log file ~/$LOG_FILE not found on remote host $HOST."
                rm -f $tmpfile
                return 1
                ;;
            255)
                print_err "Could not connect to host $HOST"
                rm -f $tmpfile
                return 1
                ;;
            *)
                print_err "Unknown error while getting log file on remote host $HOST"
                rm -f $tmpfile
                return 1
                ;;
        esac
        logfile="$tmpfile"
    fi
        
    if [ -z "$regexp" ]; then
        local date
        for date in `sort -u -k1,1 $logfile | tail -n3 | awk '{print $1}'`; do
            [ "$regexp" ] && regexp="$regexp|^$date" || regexp="^$date"
        done
    fi

    if grep -qiE "$regexp" "$logfile"; then
        grep -iE "$regexp" "$logfile" | log_color_filter
    else
        echo No log entries ${HOST:+on remote host $HOST }matched \'$regexp\'.
    fi
    [ "$tmpfile" ] && rm -f "$tmpfile"

    return 0
}

# Bourne-shell lacks support for arrays.
# These functions support management of property values in a single variable.
# List elements/values are always separated by newlines.
_ORIG_IFS="$IFS"
reset_IFS() {
    IFS="$_ORIG_IFS"
}
newline_IFS() {
    IFS='
'
}
list_append() {
    local name element current_list
    name="$1"
    element="$2"

    eval "current_list=\$$name"
    if [ -z "$current_list" ]; then
        current_list="$element"
    else
        current_list="$current_list
$element"
    fi
    eval "$name=\$current_list"
}
list_append_no_duplicates() {
    local name element current_list
    name="$1"
    element="$2"

    eval "current_list=\$$name"
    if [ -z "$current_list" ]; then
        current_list="$element"
    else
        local IFS e
        IFS='
'
        for e in $current_list; do [ "$e" = "$element" ] && return 1; done
        current_list="$current_list
$element"
    fi
    eval "$name=\$current_list"
}

LIST_RETVAL=
list_get() {
    local name index current_list
    name="$1"
    index="$2"
    [ -z "$index" ] && return 1 # no value for index
    LIST_RETVAL= # clear any old value
    eval "current_list=\$$name"
    local IFS
    IFS='
'
    local count=0
    for element in $current_list; do
        if [ $count -eq $index ]; then
            LIST_RETVAL=$element
            return 0
        fi
        count=$((count+1))
    done
    return 1
}
list_elements() {
    local name
    name="$1"
    eval "LIST_RETVAL=\$$name"
}
list_size() {
    local name current_list
    name="$1"
    eval "current_list=\$$name"
    local IFS
    IFS='
'
    local count=0
    for element in $current_list; do count=$((count+1)); done
    LIST_RETVAL=$count
}
# End of internal list utility functions

# Functions for storing parsed configuration values:
add_item() {
    eval "[ \"\$CONF_ITEM_$1\" ]" && return 1 # item already registered ..
    eval "CONF_ITEM_$1=1" # register
    list_append CONF_ITEM_LIST "$1"
}
list_items() {
    list_elements CONF_ITEM_LIST
    echo "$LIST_RETVAL"
}
have_item() {
    eval "[ \"\$CONF_ITEM_$1\" ]"
}
have_items() {
    [ "$CONF_ITEM_LIST" ]
}

add_property_value() {
    local category id prop value
    category="$1" id="$2" prop="$3" value="$4"
    list_append "CONF_PROP_${category}_${id}_${prop}" "$value"
}
add_property_value_no_duplicates() {
    local category id prop value
    category="$1" id="$2" prop="$3" value="$4"
    list_append_no_duplicates "CONF_PROP_${category}_${id}_${prop}" "$value"
}
list_property_values() {
    local category id prop
    category="$1" id="$2" prop="$3"
    list_elements "CONF_PROP_${category}_${id}_${prop}"
    echo "$LIST_RETVAL"
}
property_values_exist() {
    local category id prop
    category="$1" id="$2" prop="$3"
    eval "[ \"\$CONF_PROP_${category}_${id}_${prop}\" ]"
}

# Group management
add_item_to_group() {
    list_append_no_duplicates "CONF_GROUP_${1}_ITEMS" "$2"
    list_append_no_duplicates "CONF_GROUPS" "$1"
}
list_groups() {
    list_elements "CONF_GROUPS"
    echo "$LIST_RETVAL"
}
have_groups() {
    [ "$CONF_GROUPS" ]
}
list_group_items() {
    list_elements "CONF_GROUP_${1}_ITEMS"
    echo "$LIST_RETVAL"
}
is_group() {
    eval "[ \"\$CONF_GROUP_${1}_ITEMS\" ]"
}

# Config flag management
set_global_flag_true() {
    local flag
    flag=$1
    eval "GLOBAL_CONF_FLAG_${flag}=1"
}
set_global_flag_false() {
    local flag
    flag=$1
    eval "GLOBAL_CONF_FLAG_${flag}=0"
}
global_flag_value() {
    local flag
    flag=$1
    eval "[ \"\$GLOBAL_CONF_FLAG_${flag}\" ] && [ 1 -eq \$GLOBAL_CONF_FLAG_${flag} ]"
}

set_item_flag_true() {
    local item flag
    item=$1
    flag=$2
    eval "CONF_${item}_FLAG_${flag}=1"
}
set_item_flag_false() {
    local item flag
    item=$1
    flag=$2
    eval "CONF_${item}_FLAG_${flag}=0"
}
item_flag_value() {
    local item flag
    item=$1
    flag=$2
    eval "[ \"\$CONF_${item}_FLAG_${flag}\" ] && [ \$CONF_${item}_FLAG_${flag} -eq 1 ]"
}
item_has_flag() {
    local item flag
    item=$1
    flag=$2
    eval "[ \"\$CONF_${item}_FLAG_${flag}\" ]"
}
# Effective value means taking global value into consideration.
item_flag_effective_value() {
    local item flag
    item=$1
    flag=$2
    if item_has_flag $item $flag; then
        item_flag_value $item $flag
    else
        global_flag_value $flag
    fi
}

unset CURRENT_ITEM
CONF_GLOBAL_DEFAULT_HOST=$DS_DEFAULT_HOST
set_global_flag_true  target_deletes
set_global_flag_true  force_update
set_global_flag_false always_ask
set_global_flag_true  ask_before_kill

# Word tokenizer for config file. Tokens are separated by newlines, and
# syntactically significant newlines are represented by token '<<<EoS>>>'
# (EndofStanza). Supports quoted words, quote-escaping and comment removal.
readonly EOS='<<<EoS>>>'
token_stream() {
    awk '
      BEGIN { FS=""; }
      /^[ 	]*[^ 	]/ {
          for (i=1; i<=NF; i++) {
              if (esc) { word = word $i; esc=0; continue; }
              if ($i == "#" && !iq) { if (word) {print word; word=""; } print "'"$EOS"'"; next; }
              if ($i == "\\") {
                  esc=1;
              } else if ($i == "\"" || $i == "'\''") {
                  if (iq) {
                      if (iq == $i) {
                          if (word) print word;
                          word="";
                          iq="";
                      } else {
                          word = word $i;
                      }
                  } else {
                      iq=$i;
                  }
              } else if ($i == " " || $i == "\t") {
                  if (iq) {
                      word = word $i;
                  } else {
                      if (word) print word;
                      word="";
                  }
              } else {
                  word = word $i;
              }
          }
          if (word) print word;
          word="";
          print "'"$EOS"'";
      }' "$1"
}

parse_is_flag_arg_true() {
    case $1 in
        "") return 0 ;;
        [Yy]es | YES | 1 | [tT]rue | TRUE | [Oo]n | ON) return 0 ;;
    esac
    return 1
}

# Nice and simple, but lenient config parser which does all the things a user expects.
# Allows comments (also inline), good white-space handling, quote handling
# and checks syntax and validity.
parse_configuration() {
    local config_file
    config_file="$1"

    if [ ! -f "$config_file" ]; then
        print_err "Configuration file not found: $config_file"
        return 1
    fi

    local IFS token keyword values firstval val
    IFS='
'
    for token in `token_stream "$config_file"`; do
        if [ "$token" != "$EOS" ]; then
            if [ "$keyword" ]; then
                list_append values "$token"
            else
                keyword="$token"
            fi
            continue
        fi

        [ "$keyword" ] || { values=; continue; }
        [ "$values" ] && { list_get values 0; firstval=$LIST_RETVAL; }

        case $keyword in
            default_host)
                if [ "$CURRENT_ITEM" ]; then
                    print_err "Config: global option 'default_host' cannot be put in item context"
                    return 1
                fi
                if [ -z "$firstval" ]; then
                    print_err "Config: global option 'default_host' requires a value"
                    return 1
                fi
                CONF_GLOBAL_DEFAULT_HOST=$firstval
                ;;
                
            item)
                if ! echo $firstval|grep -Eq '^[a-zA-Z0-9_]+$'; then
                    print_err "Config: Illegal or empty item name: $firstval"
                    return 1
                elif echo $firstval|grep -iEq '^(to|from|default|with|example|items|item)$'; then
                    print_err "Config: Illegal item name: $firstval (reserved)"
                    return 1
                fi

                CURRENT_ITEM=$firstval
                add_item "$CURRENT_ITEM"
                ;;
            
            dir|dirs|directory|directories|file|files)
                if [ -z "$CURRENT_ITEM" ]; then
                    print_err "Config: encountered $keyword keyword in global context (no corresponding item)"
                    return 1
                fi
                if [ -z "$values" ]; then
                    print_err "Config (item $CURRENT_ITEM): $keyword keyword missing argument(s)"
                    return 1
                fi
                
                list_elements values
                for val in $LIST_RETVAL; do
                    if { [ "$keyword" = dir ] || [ "$keyword" = dirs ]; } && [ "${val%/}" = "$val" ]; then
                        val="$val/"
                    fi
                    add_property_value ITEM "$CURRENT_ITEM" FILES "$val"
                done
                ;;

            gconf)
                if [ -z "$CURRENT_ITEM" ]; then
                    print_err "Config: encountered $keyword keyword in global context (no corresponding item)"
                    return 1
                fi
                if [ -z "$values" ]; then
                    print_err "Config (item $CURRENT_ITEM): $keyword keyword missing argument(s)"
                    return 1
                fi
                list_elements values

                for val in $LIST_RETVAL; do
                    add_property_value ITEM "$CURRENT_ITEM" GCONF_TREES "$val"
                done
                ;;
            
            dconf)
                if [ -z "$CURRENT_ITEM" ]; then
                    print_err "Config: encountered $keyword keyword in global context (no corresponding item)"
                    return 1
                fi
                if [ -z "$values" ]; then
                    print_err "Config (item $CURRENT_ITEM): $keyword keyword missing argument(s)"
                    return 1
                fi
                list_elements values

                for val in $LIST_RETVAL; do
                    add_property_value ITEM "$CURRENT_ITEM" DCONF_TREES "$val"
                done
                ;;

            kill)
                if [ -z "$CURRENT_ITEM" ]; then
                    print_err "Config: encountered $keyword keyword in global context (no corresponding item)"
                    return 1
                fi
                if [ -z "$values" ]; then
                    print_err "Config (item $CURRENT_ITEM): $keyword keyword missing argument(s)"
                    return 1
                fi
                list_elements values
                for val in $LIST_RETVAL; do
                    add_property_value ITEM "$CURRENT_ITEM" KILLS "$val"
                done
                ;;

            cond|precondition)
                if [ -z "$CURRENT_ITEM" ]; then
                    print_err "Config: encountered $keyword keyword in global context (no corresponding item)"
                    return 1
                fi
                if [ -z "$values" ]; then
                    print_err "Config (item $CURRENT_ITEM): $keyword keyword missing argument(s)"
                    return 1
                fi
                list_elements values
                for val in $LIST_RETVAL; do
                    add_property_value ITEM "$CURRENT_ITEM" CONDS "$val"
                done
                ;;
            
            rsync_options|rsync_opts|rsync_opt|rsync_option)
                if [ -z "$CURRENT_ITEM" ]; then
                    print_err "Config: encountered $keyword keyword in global context (no corresponding item)"
                    return 1
                fi
                if [ -z "$values" ]; then
                    print_err "Config (item $CURRENT_ITEM): $keyword keyword missing argument(s)"
                    return 1
                fi
                list_elements values
                for val in $LIST_RETVAL; do
                    add_property_value ITEM "$CURRENT_ITEM" RSYNC_OPTS "$val"
                done
                ;;

            group)
                if [ -z "$CURRENT_ITEM" ]; then
                    print_err "Config: encountered $keyword keyword in global context (no corresponding item)"
                    return 1
                fi
                if echo $firstval|grep -Eqi '^default$'; then
                    firstval=default # normalize default group name
                elif ! echo $firstval|grep -Eq '^[a-zA-Z0-9_]+$'; then
                    print_err "Config: Illegal or empty group name: $firstval"
                    return 1
                elif echo $firstval|grep -iEq '^(to|from|example|items|item|with)$'; then
                    print_err "Config: Illegal group name: $firstval (reserved)"
                    return 1
                fi

                add_item_to_group "$firstval" "$CURRENT_ITEM"
                ;;
            
            always_ask | target_deletes | force_update | ask_before_kill)
                if parse_is_flag_arg_true $firstval; then
                    [ "$CURRENT_ITEM" ] && set_item_flag_true "$CURRENT_ITEM" $keyword || set_global_flag_true $keyword
                else
                    [ "$CURRENT_ITEM" ] && set_item_flag_false "$CURRENT_ITEM" $keyword || set_global_flag_false $keyword
                fi
                ;;

            *)
                print_err "Config${CURRENT_ITEM:+ (item $CURRENT_ITEM)}: unknown keyword: $keyword"
                return 1
                ;;
        esac
        keyword= values= firstval= val=
    done

    # Validate group names
    local group
    for group in `list_groups`; do
        if eval "[ \"\$CONF_ITEM_$group\" ]"; then
            print_err "Config: group name '$group' conflicts with an existing item name"
            return 2
        fi
    done
}

do_command_conf_example() {
    cat <<EOF
# Example ~/$CONFIG_FILE
# VERSION=5
#

# Set the default host / sync partner:
default_host otherlaptop

# Or you can set default host in the environment variable 'DS_DEFAULT_HOST'
# so you don't have to keep host-specifics in the config file.

# Hostnames can also be specified with "user@" first:
# default_host 'me@otherlaptop.my.domain'

# Uncomment this to globally disable default behaviour of forcing target updates:
#force_update false

# Uncomment this to globally disable default behaviour of deleting files at target
# which have been deleted at source:
#target_deletes false

# Uncomment this to trigger interactive confirmation before syncing for all items:
#always_ask true

# Uncomment this execute item process kills without any confirmation by default:
#ask_before_kill false

# Start sync item definitions:

item Foo                                          # an item named Foo
    files foofile1 foofile2                       # add files 'foofile1' and foofile2 to sync item, relative to your home directory.
    dir foodir1/                                  # add directory 'foodir1', directories are always synchronized recursively.
    dir foodir2                                   # add another directory 'foodir2'

item Bar                                          # another item named Bar
    file "a file with spaces.txt"                 # file names with spaces must be quoted
    dir /site/bar/                                # absolute path to a directory is allowed
    group default                                 # Add item to 'default' item group, which is a special group that is synced if no other
                                                  # items or groups are specified on the command line.

# Now some real apps and data:

item Firefox
     directory .mozilla/                             # Firefox profiles
     kill "^(/usr/lib/firefox-[0-9\.]+/)?firefox ?"  # Killing any running Firefox before sync is important.
                                                  # The kill pattern is a regular expression which should 
                                                  # match the command you want killed.
     ask_before_kill false                        # Don't ask if we want to kill any running, just do it.

item Shotwell
     directory .shotwell                                 # Shotwell data files
     dconf /apps/shotwell/                               # Shotwell configuration data
     kill 'shotwell' 
     kill 'something-else'                               # Multiple kill statements per item allowed
     always_ask true                                     # Always ask interactively before syncing this particular item


# A secure file system mounted ontop of an encrypted file:
item SecureFS
     file .securefs

     # Preconditions are small snippets of shell code expressions which 
     # must evaluate to true for the item sync to proceed. In this case,
     # we must never sync the file if a file system is mounted on top of it
     # (could corrupt file system at target):

     cond '! grep -q securefs /proc/mounts || { echo Warning: SecureFS is mounted locally \!; false; }'

     # HOST variable will always be set to remote host of sync
     # (so in this case we can also check if it is mounted remotely):
     cond '! ssh \$HOST grep -q securefs /proc/mounts || { echo Warning: SecureFS is mounted on remote host \$HOST \!; false; }'

     # Need rsync checksum-comparison for this file (timestamp is never updated, even if content changes), also be verbose:
     rsync_options -c -vv


item Emacs
      files .emacs  .elisp/      # ok to specify multiple files per line (yes, directories are OK for the 'files' keyword).
      group default

# Miscellaneous desktop stuff
item MiscDesktop              
    dirs  .icons/  .sounds/ .avatars/

    # Makes a two-way sync possible (push, then fetch or vice-versa):
    target_deletes  false            # Override/disable global option 'target_deletes' only for this item.
    force_update   false             # Override/disable gloabl option 'force_update' for only this item.
    group desktop                  # Add item to 'desktop' group, and to 'default' group
    group default

item FontConfig
    directory  .fonts/
    file .fonts.conf
    group desktop

# The ds shell script itself:
item ds
file bin/ds

item SSHConfig
  file .ssh/config
  force_update 0  # Override/disable global option 'force_update' only for this item.

# End of file.
EOF
}

do_command_bashcomp() {
    # FIXME: This completion code got slightly too complex in the end 
    #        Needs re-write/clean up.
    cd "`dirname $0`"
    local ds_cmd="`pwd`/`basename $0`"

    print "# `basename $0` context sensitive command line auto-completion (Bash)"
    print "# generated by `basename $0` v$VERSION"
    print "__DS_CMD=$ds_cmd"
    print '__DS_COMP_ITEMS='
    print '__DS_CONFIG_TIMESTAMP=0'
    print '_ds_completion() {'
    print "    local config_file=\"\$HOME/$CONFIG_FILE\""
    cat <<"EOF"

    COMPREPLY=()
    if [ -f "$config_file" ]; then
        local mtime=$(date -r "$config_file" +'%s')
        if [ -z "$__DS_COMP_ITEMS" ] || [ $mtime -gt $__DS_CONFIG_TIMESTAMP ]; then
            __DS_CONFIG_TIMESTAMP=$mtime
            __DS_COMP_ITEMS=$($__DS_CMD __compitems)
        fi
    fi

    local COMMANDS="push fetch conf log bashcomp"
    local OPTIONS="c Y i v z n l u V h H"
    local state=first cursorstate= j=0 word
    for word in "${COMP_WORDS[@]}"; do
        case $state in
            first)
                # move on to options_or_command state
                state=options_or_command
                ;;

            options_or_command)
                if [ "${word:0:1}" = - ]; then
                    # option word
                    local options= o
                    for o in $OPTIONS; do
                        if [ "${word#*${o}*}" != "$word" ]; then
                            options="$options $o"
                        fi
                    done

                    local provided_options
                    if [ "$options" ]; then
                        provided_options="$provided_options $options"
                    fi
                elif [ "$word" ]; then
                    local command= c
                    for c in $COMMANDS; do
                        if [ "$word" = "$c" ]; then
                            command=$word
                            break
                        fi
                    done

                    if [ "$command" ]; then
                        state=$command
                    else
                        # no valid command present, break here
                        break
                    fi
                fi
                ;;

            push)
                local pushargs=1
                if [ "$word" ]; then
                    if [ "$word" = to ]; then
                        [ -z "$host" ] && state=host || break
                    else
                        local item= i
                        for i in $__DS_COMP_ITEMS; do
                            if [ "$word" = "$i" ]; then
                                item=$word
                                break
                            fi
                        done

                        local provided_items
                        if [ "$item" ]; then
                            provided_items="$provided_items $item"
                        fi
                    fi
                fi
                ;;

            fetch)
                local fetchargs=1
                if [ "$word" ]; then
                    if [ "$word" = from ]; then
                        [ -z "$host" ] && state=host || break
                    else
                        local item= i
                        for i in $__DS_COMP_ITEMS; do
                            if [ "$word" = "$i" ]; then
                                item=$word
                                break
                            fi
                        done

                        local provided_items
                        if [ "$item" ]; then
                            provided_items="$provided_items $item"
                        fi
                    fi
                fi
                ;;

            log)
                local logargs=1
                if [ "$word" ]; then
                    local logarg_all logarg_clear logarg_lastop
                    case $word in
                        all) logarg_all=1 ;;
                        clear) logarg_clear=1 ;;
                        lastop) logarg_lastop=1 ;;
                        remote)
                            [ -z "$host" ] && state=host || break ;;
                        match)
                            [ -z "$matchregexp" ] && state=logmatch || break ;;
                        *)
                            break ;;
                    esac
                fi
                ;;

            logmatch)
                local logmatchargs=1
                if [ "$word" ]; then
                    local matchregexp
                    matchregexp=$word
                    if [ $j != $COMP_CWORD ]; then state=log; fi
                fi
                ;;

            conf)
                local confargs=1
                local confarg_example confarg_items
                case $word in
                  example) confarg_example=1 ;;
                  items) confarg_items=1 ;;
                  *) 
                     local item= i
                     for i in $__DS_COMP_ITEMS; do
                         if [ "$word" = "$i" ]; then
                             item=$word
                             break
                         fi
                     done
                     local provided_items
                     if [ "$item" ]; then
                         provided_items="$provided_items $item"
                     fi
                   ;;
                esac
                ;;

            bashcomp)
                local bashcompargs=1
                break # command takes no arguments
                ;;

            host)
                local hostargs=1 host
                if [ "$word" ]; then
                    host=$word
                    if [ $j != $COMP_CWORD ]; then state=$command; fi
                fi
                ;;
        esac
        if [ $j = $COMP_CWORD ]; then cursorstate=$state; fi # save state in which cursor is currently at
        j=$((j+1))
    done
    if [ -z "$cursorstate" ]; then cursorstate=$state; fi

    # Now do completion based on cursor state and rest of context
    case $cursorstate in
        options_or_command)
            local options= o curword
            curword=${COMP_WORDS[COMP_CWORD]}

            if [ "$curword" ] && [ -z "$command" ] && [ "${curword:0:1}" != - ]; then
                COMPREPLY=($(compgen -W "$COMMANDS" -- ${COMP_WORDS[COMP_CWORD]}))
                return 0
            fi

            for o in $OPTIONS; do
                local provided_option
                for provided_option in $provided_options; do
                    if [ "$provided_option" = "$o" ]; then
                        continue 2
                    fi
                done
                options="$options -$o"
            done

            local compcur=
            [ "$curword" != - ] && compcur=$curword
            if [ -z "$command" ]; then
                COMPREPLY=($(compgen -W "$options $compcur $COMMANDS" -- ${COMP_WORDS[COMP_CWORD]}))
            else
                COMPREPLY=($(compgen -W "$options $compcur" -- ${COMP_WORDS[COMP_CWORD]}))
            fi
            ;;

        push|fetch)
            if [ -z "$pushargs" ] && [ -z "$fetchargs" ]; then
                if [ "${COMP_WORDS[COMP_CWORD]}" = fetch ]; then
                    COMPREPLY=(fetch); return
                elif [ "${COMP_WORDS[COMP_CWORD]}" = push ]; then
                    COMPREPLY=(push); return
                fi
            fi

            local items
            items=$($__DS_CMD __compitems $provided_items)

            if [ -z "$host" ]; then
                [ $cursorstate = fetch ] && tofrom=from || tofrom=to
                COMPREPLY=($(compgen -W "$items $tofrom" -- ${COMP_WORDS[COMP_CWORD]}))
            else
                COMPREPLY=($(compgen -W "$items" -- ${COMP_WORDS[COMP_CWORD]}))
            fi
            ;;

        conf)
            local reply=
            if [ "$provided_items" ]; then
                reply=$($__DS_CMD __compitems $provided_items)
            else
                if [ "${COMP_WORDS[COMP_CWORD]}" = conf ] && [ -z "$confargs" ]; then
                    reply=conf
                elif [ "$confarg_items" ]; then
                    if [ "${COMP_WORDS[COMP_CWORD]}" = items ]; then reply=items; else reply=; fi
                elif [ "$confarg_example" ]; then
                    if [ "${COMP_WORDS[COMP_CWORD]}" = example ]; then reply=example; else reply=; fi
                else
                    reply="example items $($__DS_CMD __compitems $provided_items)"
                fi
            fi

            COMPREPLY=($(compgen -W "$reply" -- ${COMP_WORDS[COMP_CWORD]}))
            ;;

        log)
            local reply=
            if [ "${COMP_WORDS[COMP_CWORD]}" = log ] && [ -z "$logargs" ]; then
                reply=log
            else
                if [ "$logarg_lastop" ] && [ "$logarg_all$logarg_clear$matchregexp" ]; then return; fi # invalid combo
                if [ "$logarg_all" ] && [ "$logarg_clear$matchregexp$logarg_lastop" ]; then return; fi # invalid combo
                if [ "$logarg_clear" ] && [ "$matchregexp$logarg_all$logarg_lastop" ]; then return; fi # invalid combo

                if [ "$logarg_clear" ] || [ "$logarg_all" ] || [ "$matchregexp" ] || [ "$logarg_lastop" ]; then
                    case ${COMP_WORDS[COMP_CWORD]} in
                        clear) reply=clear ;;
                        all) reply=all ;;
                        lastop) reply=lastop ;;
                    esac
                    [ -z "$host" ] && reply="$reply remote"
                else
                    [ -z "$host" ] && reply="remote"
                    reply="$reply all clear match lastop"
                fi
            fi
            COMPREPLY=($(compgen -W "$reply" -- ${COMP_WORDS[COMP_CWORD]}))
            ;;

        host)
            local reply=
            if [ -z "$hostargs" ]; then
                if [ "${COMP_WORDS[COMP_CWORD]}" = to ] || [ "${COMP_WORDS[COMP_CWORD]}" = from ] || [ "${COMP_WORDS[COMP_CWORD]}" = remote ]; then
                    reply=${COMP_WORDS[COMP_CWORD]}
                fi
            elif [ -f ~/.ssh/config ]; then
                # Complete on hosts found in ~/.ssh/config
                local hosts= host
                for host in $(awk '/^[ 	]*host[ 	]/ {for (i=2; i<=NF; i++) { if ($i != "*") printf("%s ",$i);}}' < ~/.ssh/config); do
                    hosts="$hosts $host"
                done
                reply=$hosts
            fi
            COMPREPLY=($(compgen -W "$reply" -- ${COMP_WORDS[COMP_CWORD]}))
            ;;

        logmatch)
            local reply
            if [ "${COMP_WORDS[COMP_CWORD]}" = match ] && [ -z "$logmatchargs" ]; then
                reply=match
            else
                reply=$__DS_COMP_ITEMS
            fi
            # Complete on configured item names (for easy filtering of certain items from log)
            COMPREPLY=($(compgen -W "$reply" -- ${COMP_WORDS[COMP_CWORD]}))
            ;;

        bashcomp)
            if [ "${COMP_WORDS[COMP_CWORD]}" = bashcomp ] && [ -z "$bashcompargs" ]; then
                COMPREPLY=(bashcomp)
            fi
            ;;
    esac
}
EOF
    print "complete -F _ds_completion $(basename $0)"
    print '# End of ds command line auto-completion code.'
}

do_command_conf_items() {
    if have_items; then
        if [ "$1" ]; then
            # print details for each item or group
            local x
            for x in $*; do
                if is_group $x; then
                    local items item
                    items=`list_group_items $x`
                    print -n "Group "; print_magenta -n "$x: "
                    print_cyan $items
                    for item in $items; do
                        conf_print_item $item
                        print
                    done
                elif have_item $x; then
                    conf_print_item $x
                else
                    print_err "Unknown item or group: $x"
                fi
                print
            done
            return 0
        fi
        
        print_green 'Items: '
        print_cyan " " `list_items`
        if have_groups; then
            print
            print_green "Item groups:"
            local group
            for group in `list_groups`; do
                print_magenta -n "  $group"
                print -n ': '; print_cyan `list_group_items $group`
            done
            print
        fi
    else
        print 'No items are configured.'
    fi
}

conf_print_item() {
    local item
    item="$1"
    
    local IFS
    IFS='
'
    print -n "Item "; print_cyan "$item"
    local file kill cond tree
    for file in `list_property_values ITEM $item FILES`; do
        print "  $file"
    done

    for tree in `list_property_values ITEM $item GCONF_TREES`; do
        print_yellow -n "  GConf-tree  "; print "$tree"
    done
    for tree in `list_property_values ITEM $item DCONF_TREES`; do
        print_yellow -n "  dconf tree  "; print "$tree"
    done

    for kill in `list_property_values ITEM $item KILLS`; do
        print_red -n "  Kill "
        print -n "processes matching  '$kill'"
        if item_has_flag $item ask_before_kill; then
            ! item_flag_value $item ask_before_kill && print -n " (NO confirmation)"
        fi
        print
    done

    for cond in `list_property_values ITEM $item CONDS`; do
        print "  Precondition:	'$cond'"
    done

    if property_values_exist ITEM $item RSYNC_OPTS; then
        print -n "  Extra rsync options:	"
        for opt in `list_property_values ITEM $item RSYNC_OPTS`; do
            print -n "$opt "
        done
        print
    fi

    if item_has_flag $item force_update; then
        if item_flag_value $item force_update; then
            print "  Forced updates enabled for item (force_update)"
        else
            print "  Forced updates disabled for item (force_update false)"
        fi
    fi

    if item_has_flag $item target_deletes; then
        if item_flag_value $item target_deletes; then
            print "  Target deletes enabled for item (target_deletes)"
        else
            print "  Target deletes disabled for item (target_deletes false)"
        fi
    fi

    if item_has_flag $item always_ask; then
        if item_flag_value $item always_ask; then
            print "  Item always triggers interactive confirmation (always_ask)"
        else
            print "  Item never triggers interactive configuration (always_ask false)"
        fi
    fi

}

do_command_conf() {
    if [ "$CONF_GLOBAL_DEFAULT_HOST" ]; then
        print_green -n "Default sync partner: "; print "$CONF_GLOBAL_DEFAULT_HOST"
        print
    fi

    if ! global_flag_value force_update; then
        print_green -n "Global setting: "
        print force_update false
        print "Target files will only be updated if source file is newer."
        print
    fi
    if ! global_flag_value target_deletes; then
        print_green -n "Global setting: "
        print target_deletes false
        print "No files will be deleted from target directory trees, even if deleted at source."
        print
    fi
    if ! global_flag_value ask_before_kill; then
        print_green -n "Global setting: "
        print ask_before_kill false
        print "Do not ask for confirmation when executing process kills before item sync."
        print
    fi
    if global_flag_value always_ask; then
        print_green -n "Global setting: "
        print always_ask true
        print "Enabled interactive confirmation before syncing for all items."
        print
    fi

    if ! have_items; then
        print "No items are configured."
        return 0
    fi

    if have_groups; then
        print_green "Item groups:"
        for group in `list_groups`; do
            print_magenta -n "  $group"
            print -n ': '; print_cyan `list_group_items $group`
        done
        print
    fi
    
    print_green 'Configured items:'

    local IFS
    newline_IFS
    for item in `list_items`; do
        conf_print_item $item
        print
    done
}

usage() {
    print "ds v$VERSION"
    print
    print "ds is a command line tool for manual, but quick and easy one-way syncing/mirroring"
    print "of data to/from remote hosts. It primarily uses rsync(1) and ssh(1) to accomplish"
    print "its tasks. GConf and dconf sync requires a typical Linux desktop installation (optional)."
    print
    print -n "Use: `basename $0`"; print_green -n " [options] "
    print_cyan -n "COMMAND"
    print " [command-args]"
    print
    print "Commands:"
    print_cyan -n "push  "
    print "[to [USER@]HOST] [ITEM1 ITEM2 GROUP3 [..]]"
    print "      Synchronize by pushing items to remote host."
    print
    print_cyan -n "fetch "
    print "[from [USER@]HOST] [ITEM1 ITEM2 GROUP3 [..]]"
    print "      Synchronize by fetching items from remote host."
    print
    if [ "$1" ]; then
        print -n "      If no host is specified for "; print_cyan -n push; print -n " or "; print_cyan -n fetch; 
        print " the configured default-"
        print "      host will be used."
        print -n "      If no items are specified for "; print_cyan -n push; print -n " or "; print_cyan -n fetch
        print ", then all items in the 'default' group are processed."
        print "      Specified item or group names are matched case-insensitively and you can use simple"
        print "      regular expressions, like in grep(1). When specifying a group, then all items"
        print "      in that group are processed."
        print
        print "      The standard behaviour of ds is to mirror the source at the target."
        print "      This implies two important things:"
        print "      1) If a file has been deleted from a directory tree at the source, it will"
        print "         also be deleted at the target."
        print "      2) Even files that are newer at the target will be update from source files."
        print
        print "      This behaviour ensures consistent/identical data on both ends after"
        print "      a sync, which is suitable for application configuration directories, etc."
        print
        print "      If you would like to do two-way syncing for some items, you can override this"
        print "      default behaviour by setting the options 'target_deletes' and 'force_update'"
        print "      to false in the item configuration. You can then accomplish two-way syncing"
        print -n "      by first doing a 'push', then a 'fetch'. Or you can supply the "; print_green -n "option "; print "'-u'"
        print "      when invoking ds from the command line, which will enable this behaviour"
        print "      (and override anything set in config) for that run."
        print
    fi
    print_cyan -n "log   "
    print "[all] [match REGEXP] [clear] [lastop] [remote [[USER@]HOST]]"
    print "      Shows  entries from the local (or remote) log file."
    if [ "$1" ]; then
        print "      By default, only entries for the last three logged days are shown."
        print "      You can optionally specify 'all', which will show all entries, or 'match REGEXP',"
        print "      which will show all entries matching a given regular expression"
        print "      (matching is case-insensitive)."
        print "      If 'clear' is specified, then the log file is cleared of all entries."
        print "      If 'lastop' is specified, then the last logged operation for each item or group is shown."
        print "      If a remote host is specified, then the log on that host is operated upon."
    fi
    print
    print_cyan -n "stat  "
    print "ITEM1 ITEM2 GROUP3 [with [USER@]HOST]"
    print "      Show a simple synchronization status for each item against remote host."
    if [ "$1" ]; then
        print "      If HOST is omitted, then the default sync partner host will be used."
        print "      Only status of regular files and/or directories can be checked. Other types,"
        print "      such dconf/gconf, will be ignored. The status check does the following:"
        print "      For each item:"
        print "        1. Check if rsync would add/update/delete any remote files on push."
        print "        2. Check if rsync would add/update/delete any local files on fetch."
        print "        3. Report status."
    fi
    print
    print_cyan -n "conf  "; print "[example] [items] [ITEM or GROUP]"
    print "      Parses and prints current configuration."
    if [ "$1" ]; then
        print "      If 'example' is specified, then an example configuration file"
        print "      is printed to standard out. If 'items' is specified, then only"
        print "      item names and groups are listed. Otherwise, arguments are assumed"
        print "      to be item or group names for which config should be printed."
    fi
    print
    print_cyan "bashcomp"
    print "      This special command emits BASH script code for supporting ds"
    print "      command line auto-completion. You can put the output in a file and"
    print "      source it from ~/.bashrc or equivalent."
    print
    print_green "Options:"
    print "-i    Ask before syncing each item."
    print "-Y    Automatically answer YES to all interactive questions."
    print "-z    Use compression for data-transfers to/from remote host."
    print "-u    Disable options 'force_update' and 'target_deletes'"
    print "      for all items regardless of what is set in config."
    print "-n    Enable dry-run mode. Useful to see what rsync would do."
    print "-l    Do not update any log files."
    print "-c    Enable colors in terminal output."
    print "-v    Display verbose output."
    print "-V    Show version."
    print "-h    This help."
    print "-H    Show detailed help/manual."
    exit 255
}

trap 'echo && echo Interrupted, quitting. && exit 255' INT

version() {
    echo "ds $VERSION"
    exit 0
}

GLOPT_YES=
GLOPT_INT=
GLOPT_VERB=
GLOPT_COMP=
GLOPT_COLORS=
GLOPT_DRYRUN=
GLOPT_NOLOG=
GLOPT_ONLY_UPDATE=
while getopts "cYivznluVhH" opt; do
    case $opt in
        c) GLOPT_COLORS=1 ;;
        Y) GLOPT_YES=1 ;;
        i) GLOPT_INT=1 ;;
        v) GLOPT_VERB=1 ;;
        z) GLOPT_COMP=1 ;;
        n) GLOPT_DRYRUN=1 ;;
        l) GLOPT_NOLOG=1 ;;
        u) GLOPT_ONLY_UPDATE=1 ;;
        V) version ;;
        h) usage ;;
        H) usage detailed ;;
        ?) print_err "Invalid option: '$1'"; usage ;;
    esac
done
shift `expr $OPTIND - 1`

COMMAND=
SELECTED_ITEMS=
HOST=
LOG_CLEAR=
LOG_REMOTE=
LOG_REGEXP=
LOG_ALL=
LOG_LASTOP=

# Set basedir to HOME
cd "$HOME"

# Parse and validate command
[ -z "$1" ] && usage
COMMAND=$1
shift
case "$COMMAND" in
    push|fetch|stat)
        parse_configuration "$HOME/$CONFIG_FILE"
        retcode=$?
        if [ $retcode -ne 0 ]; then
            print_err "Failed to parse configuration."
            exit $retcode
        fi
        
        if ! have_items; then
            print_err "You have not configured any items."
            exit 2
        fi

        type ssh 1>/dev/null 2>&1 || {
            print_err "Missing required dependency: ssh"
            print_err "It has to be available somewhere in your PATH."
            return 255
        }
        
        if [ "$1" ]; then
            while [ "$1" ]; do
                case $1 in
                    to|from)
                        if { [ "$1" = "to" ] || [ "$1" = "TO" ] || [ "$1" = "To" ]; } && [ "$COMMAND" = fetch ]; then
                            print_err "Cannot \"fetch to\" a host, did you mean \"fetch from ..\" ?"
                            usage
                        fi

                        if { [ "$1" = "from" ] || [ "$1" = "FROM" ] || [ "$1" = "From" ]; } && [ "$COMMAND" = push ]; then
                            print_err "Cannot \"push from\" a host, did you mean \"push to ..\" ?"
                            usage
                        fi
                        if [ -z "$2" ]; then
                            print_err "No [USER@]HOST specified after 'from' or 'to'."
                            usage
                        fi
                        HOST="$2"
                        shift
                        ;;
                    with)
                        if [ $COMMAND != stat ]; then
                            print_err "Keyword 'with' can only be used with stat command."
                            usage
                        fi
                        if [ -z "$2" ]; then
                            print_err "No [USER@]HOST specified after 'with'."
                            usage
                        fi
                        HOST="$2"
                        shift
                        ;;
                    *)
                        SELECTED_ITEMS="$SELECTED_ITEMS $1"
                        ;;
                esac
                shift
            done
        fi

        if [ -z "$HOST" ]; then
            if [ -z "$CONF_GLOBAL_DEFAULT_HOST" ]; then
                print_err "No [USER@]HOST specified and no default host configured."
                usage
            else
                HOST=$CONF_GLOBAL_DEFAULT_HOST
            fi
        fi

        if [ -z "$SELECTED_ITEMS" ]; then
            if ! is_group default; then
                print_err "No items selected, and no items have been assigned to the 'default' group."
                exit 2
            fi
            SELECTED_ITEMS=default
        fi

        # Build requested item list
        selections=
        found=
        for selected in $SELECTED_ITEMS; do
            found=
            newline_IFS
            for confitem in `list_items`; do
                if echo "$confitem"|grep -qi "^${selected}\$"; then
                    selections="$selections $confitem"
                    found=1
                    break
                fi
            done
            if [ -z "$found" ]; then
                for confgroup in `list_groups`; do
                    if echo "$confgroup"|grep -qi "^${selected}\$"; then
                        selections="$selections $confgroup"
                        found=1
                        break
                    fi
                done
            fi
            reset_IFS
            
            if [ -z "$found" ]; then
                print_warn "No configured item or group matching '$selected' was found."
            fi
        done
        
        if [ -z "$selections" ]; then
            print_err "No matching items or groups found in configuration."
            exit 2
        fi
        
        if [ $COMMAND = stat ]; then
            print "Status with remote host: $HOST"
        else
            print "Remote host: $HOST"
        fi
        print
        print "Selected items and groups: "
        for selection in $selections; do
            if is_group $selection; then
                if [ $selection = default ]; then
                    print_magenta -n "  default"
                else
                    print_cyan -n "  $selection"
                fi
                print -n ': '
                print_cyan `list_group_items $selection`
            else
                print_cyan "  $selection"
            fi
        done

        if [ "$GLOPT_DRYRUN" ] && [ $COMMAND != stat ]; then
            print
            print "Dry run only"
        fi

        CURRENT_GROUP=
        CURRENT_ITEM=
        OP=$COMMAND
        for selection in $selections; do
            if is_group $selection; then
                CURRENT_GROUP=$selection
                for item in `list_group_items $selection`; do
                    CURRENT_ITEM=$item
                    print 
                    print -n "Item ";print_cyan $CURRENT_ITEM
                    if [ $COMMAND = stat ]; then
                        do_command_stat
                    else
                        do_command_sync
                    fi
                    print
                done
            else
                CURRENT_GROUP=
                CURRENT_ITEM=$selection
                print
                print -n "Item ";print_cyan $CURRENT_ITEM
                if [ $COMMAND = stat ]; then
                    do_command_stat
                else
                    do_command_sync
                fi
                print
            fi
        done
        ;;

    conf*)
        if [ "$1" != example ]; then
            parse_configuration "$HOME/$CONFIG_FILE"
            if [ $? -ne 0 ]; then
                print_err "Failed to parse configuration."
                exit 255
            fi
        fi
        
        if [ "$1" ]; then
            if [ "$1" = example ]; then
                do_command_conf_example
            elif [ "$1" = items ]; then
                do_command_conf_items
            else
               # Assume args are item or group names to be displayed
                do_command_conf_items "$@"
            fi
        else
            do_command_conf
        fi
        ;;
        
    log)
        parse_configuration "$HOME/$CONFIG_FILE"
        if [ $? -ne 0 ]; then
            print_err "Failed to parse configuration."
            exit 255
        fi
        while [ "$1" ]; do
            case "$1" in
                all) LOG_ALL=1 ;;
                clear) LOG_CLEAR=1 ;;
                lastop) LOG_LASTOP=1 ;;
                match)
                    if [ -z "$2" ]; then
                        print_err "Missing regular expression after 'match'"
                        usage
                    fi
                    LOG_REGEXP="$2"; shift
                    ;;
                remote)
                    LOG_REMOTE=1
                    if [ -z "$2" ]; then
                        if [ -z "$CONF_GLOBAL_DEFAULT_HOST" ]; then
                            print_err "Missing '[USER@]HOST' after 'remote' and no default host configured"
                            usage
                        else
                            HOST=$CONF_GLOBAL_DEFAULT_HOST
                        fi
                    else
                        HOST=$2; shift
                    fi
                    ;;
                *)
                    print_err "Unknown argument to 'log' command: '$1'"
                    usage
                    ;;
            esac
            shift
        done
        do_command_log
        ;;

    bashcomp)
        if [ "$1" ]; then
            print_err "The 'bashcomp' command does not take any arguments."
            usage
        fi
        do_command_bashcomp
        ;;

    __compitems)
        # Private command, used by auto-completion code. Be silent and fast in general.
        parse_configuration "$HOME/$CONFIG_FILE" 1>/dev/null 2>&1 || exit 1
        retval=
        provided=
        while [ "$1" ]; do
            if is_group $1; then
                provided="$provided `list_group_items $1` $1"
            fi
            provided="$provided $1"
            shift
        done
        list_elements CONF_ITEM_LIST
        items=$LIST_RETVAL
        list_elements CONF_GROUPS
        groups=$LIST_RETVAL

        for selection in $items $groups; do
            for p in $provided; do
                [ $p = $selection ] && continue 2
            done
            retval="$retval $selection"
        done
        echo $retval
        exit 0
        ;;

    *)
        print_err "Unknown command '$COMMAND'"; usage ;;
    "")
        usage ;;
esac

exit 0

